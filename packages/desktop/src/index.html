<!DOCTYPE html>
<html>

<head>
    <script>
        class Interpreter {
            constructor(root) {
                this.root = root;
                this.stack = [root];
                this.listeners = {
                    "onclick": {}
                };
                this.lastNodeWasText = false;
                this.nodes = [root, root, root, root];
            }

            top() {
                return this.stack[this.stack.length - 1];
            }

            pop() {
                return this.stack.pop();
            }

            PushRoot(edit) {
                const id = edit.id;
                const node = this.nodes[id];
                console.log("pushing root ", node, "with id", id);
                this.stack.push(node);
            }

            PopRoot(edit) {
                this.stack.pop();
            }

            AppendChildren(edit) {
                let root = this.stack[this.stack.length - (edit.many + 1)];
                for (let i = 0; i < edit.many; i++) {
                    console.log("popping ", i, edit.many);
                    let node = this.pop();
                    root.appendChild(node);
                }
            }

            ReplaceWith(edit) {

                let root = this.stack[this.stack.length - (edit.many + 1)];
                let els = [];

                for (let i = 0; i < edit.many; i++) {
                    els.push(this.pop());
                }

                root.replaceWith(...els);
            }

            Remove(edit) {
                const node = this.stack.pop();
                node.remove();
            }

            RemoveAllChildren(edit) {}

            CreateTextNode(edit) {
                const node = document.createTextNode(edit.text);
                this.nodes[edit.id] = node;
                this.stack.push(node);
            }

            CreateElement(edit) {
                const tagName = edit.tag;
                const el = document.createElement(tagName);
                this.nodes[edit.id] = el;
                console.log(`creating element: `, edit);
                this.stack.push(el);
            }

            CreateElementNs(edit) {
                const tagName = edit.tag;
                console.log(`creating namespaced element: `, edit);
                this.stack.push(document.createElementNS(edit.ns, edit.tag));
            }

            CreatePlaceholder(edit) {
                const a = `this.stack.push(document.createElement(" pre"))`;
                this.stack.push(document.createComment("vroot"));
            }

            NewEventListener(edit) {
                const element_id = edit.element_id;
                const event_name = edit.event_name;
                const mounted_node_id = edit.mounted_node_id;
                const scope = edit.scope;

                const element = this.top();
                element.setAttribute(`dioxus-event-${event_name}`, `${scope}.${mounted_node_id}`);

                console.log("listener map is", this.listeners);
                if (this.listeners[event_name] === undefined) {
                    console.log("adding listener!");
                    this.listeners[event_name] = "bla";
                    this.root.addEventListener(event_name, (event) => {
                        const target = event.target;
                        const type = event.type;
                        const val = target.getAttribute(`dioxus-event-${event_name}`);
                        const fields = val.split(".");
                        const scope_id = parseInt(fields[0]);
                        const real_id = parseInt(fields[1]);

                        console.log(`parsed event with scope_id ${scope_id} and real_id ${real_id}`);

                        rpc.call('user_event', {
                            event: event_name,
                            scope: scope_id,
                            mounted_dom_id: real_id,
                        }).then((reply) => {
                            console.log(reply);
                            this.stack.push(this.root);

                            for (let x = 0; x < reply.length; x++) {
                                let edit = reply[x];
                                console.log(edit);

                                let f = this[edit.type];
                                f.call(this, edit);
                            }

                            console.log("initiated");
                        }).catch((err) => {
                            console.log("failed to initiate", err);
                        });
                    });
                }
            }

            RemoveEventListener(edit) {}

            SetText(edit) {
                this.top().textContent = edit.text;
            }

            SetAttribute(edit) {
                const name = edit.field;
                const value = edit.value;
                const ns = edit.ns;
                const node = this.top(this.stack);
                if (ns == "style") {
                    node.style[name] = value;
                } else if (ns !== undefined) {
                    node.setAttributeNS(ns, name, value);
                } else {
                    node.setAttribute(name, value);
                }
                if (name === "value") {
                    node.value = value;
                }
                if (name === "checked") {
                    node.checked = true;
                }
                if (name === "selected") {
                    node.selected = true;
                }
            }
            RemoveAttribute(edit) {
                const name = edit.field;
                const node = this.top(this.stack);
                node.removeAttribute(name);

                if (name === "value") {
                    node.value = null;
                }
                if (name === "checked") {
                    node.checked = false;
                }
                if (name === "selected") {
                    node.selected = false;
                }
            }
        }




        async function initialize() {
            const reply = await rpc.call('initiate');
            const interpreter = new Interpreter(window.document.getElementById("_dioxusroot"));
            console.log(reply);

            for (let x = 0; x < reply.length; x++) {
                let edit = reply[x];
                console.log(edit);

                let f = interpreter[edit.type];
                f.call(interpreter, edit);
            }

            console.log("stack completed: ", interpreter.stack);
        }
        console.log("initializing...");
        initialize();
    </script>
</head>

<body>
    <div id="_dioxusroot">
    </div>
</body>

</html>
