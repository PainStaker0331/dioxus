<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/desktop.html"><strong aria-hidden="true">1.1.</strong> Desktop</a></li><li class="chapter-item expanded "><a href="getting_started/web.html"><strong aria-hidden="true">1.2.</strong> Web</a></li><li class="chapter-item expanded "><a href="getting_started/ssr.html"><strong aria-hidden="true">1.3.</strong> Server-Side Rendering</a></li><li class="chapter-item expanded "><a href="getting_started/fullstack.html"><strong aria-hidden="true">1.4.</strong> Fullstack</a></li><li class="chapter-item expanded "><a href="getting_started/liveview.html"><strong aria-hidden="true">1.5.</strong> Liveview</a></li><li class="chapter-item expanded "><a href="getting_started/tui.html"><strong aria-hidden="true">1.6.</strong> Terminal UI</a></li><li class="chapter-item expanded "><a href="getting_started/mobile.html"><strong aria-hidden="true">1.7.</strong> Mobile</a></li><li class="chapter-item expanded "><a href="getting_started/hot_reload.html"><strong aria-hidden="true">1.8.</strong> Hot Reloading</a></li></ol></li><li class="chapter-item expanded "><a href="describing_ui/index.html"><strong aria-hidden="true">2.</strong> Describing the UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="describing_ui/special_attributes.html"><strong aria-hidden="true">2.1.</strong> Special Attributes</a></li><li class="chapter-item expanded "><a href="describing_ui/components.html"><strong aria-hidden="true">2.2.</strong> Components</a></li><li class="chapter-item expanded "><a href="describing_ui/component_props.html"><strong aria-hidden="true">2.3.</strong> Props</a></li><li class="chapter-item expanded "><a href="describing_ui/component_children.html"><strong aria-hidden="true">2.4.</strong> Component Children</a></li></ol></li><li class="chapter-item expanded "><a href="interactivity/index.html"><strong aria-hidden="true">3.</strong> Interactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interactivity/event_handlers.html"><strong aria-hidden="true">3.1.</strong> Event Listeners</a></li><li class="chapter-item expanded "><a href="interactivity/hooks.html"><strong aria-hidden="true">3.2.</strong> Hooks &amp; Component State</a></li><li class="chapter-item expanded "><a href="interactivity/user_input.html"><strong aria-hidden="true">3.3.</strong> User Input</a></li><li class="chapter-item expanded "><a href="interactivity/sharing_state.html"><strong aria-hidden="true">3.4.</strong> Sharing State</a></li><li class="chapter-item expanded "><a href="interactivity/custom_hooks.html"><strong aria-hidden="true">3.5.</strong> Custom Hooks</a></li><li class="chapter-item expanded "><a href="interactivity/dynamic_rendering.html"><strong aria-hidden="true">3.6.</strong> Dynamic Rendering</a></li><li class="chapter-item expanded "><a href="interactivity/router.html"><strong aria-hidden="true">3.7.</strong> Routing</a></li></ol></li><li class="chapter-item expanded "><a href="async/index.html"><strong aria-hidden="true">4.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="async/use_future.html"><strong aria-hidden="true">4.1.</strong> UseFuture</a></li><li class="chapter-item expanded "><a href="async/use_coroutine.html"><strong aria-hidden="true">4.2.</strong> UseCoroutine</a></li><li class="chapter-item expanded "><a href="async/spawn.html"><strong aria-hidden="true">4.3.</strong> Spawning Futures</a></li></ol></li><li class="chapter-item expanded "><a href="best_practices/index.html"><strong aria-hidden="true">5.</strong> Best Practices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="best_practices/error_handling.html"><strong aria-hidden="true">5.1.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="best_practices/antipatterns.html"><strong aria-hidden="true">5.2.</strong> Antipatterns</a></li></ol></li><li class="chapter-item expanded "><a href="publishing/index.html"><strong aria-hidden="true">6.</strong> Publishing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="publishing/desktop.html"><strong aria-hidden="true">6.1.</strong> Desktop</a></li><li class="chapter-item expanded "><a href="publishing/web.html"><strong aria-hidden="true">6.2.</strong> Web</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="fullstack/index.html"><strong aria-hidden="true">7.</strong> Fullstack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fullstack/getting_started.html"><strong aria-hidden="true">7.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="fullstack/server_functions.html"><strong aria-hidden="true">7.2.</strong> Communicating with the Server</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="custom_renderer/index.html"><strong aria-hidden="true">8.</strong> Custom Renderer</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">9.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/project_structure.html"><strong aria-hidden="true">9.1.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="contributing/walkthrough_readme.html"><strong aria-hidden="true">9.2.</strong> Walkthrough of Internals</a></li><li class="chapter-item expanded "><a href="contributing/guiding_principles.html"><strong aria-hidden="true">9.3.</strong> Guiding Principles</a></li><li class="chapter-item expanded "><a href="contributing/roadmap.html"><strong aria-hidden="true">9.4.</strong> Roadmap</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <button id="language-toggle" class="icon-button" type="button" title="Select language" aria-label="Select language" aria-haspopup="true" aria-expanded="false" aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="language-popup" aria-label="Languages" role="menu">
                            <li role="none"><a href="../en/print.html"><button role="menuitem" class="language" id="light">English</button></a></li>
                            <li role="none"><a href="../pt-br/print.html"><button role="menuitem" class="language" id="light">Português Brasileiro</button></a></li>
                        </ul>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DioxusLabs/dioxus/edit/master/docs/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./images/dioxuslogo_full.png" alt="dioxuslogo" /></p>
<p>Dioxus is a portable, performant, and ergonomic framework for building cross-platform user interfaces in Rust. This guide will help you get started with writing Dioxus apps for the Web, Desktop, Mobile, and more.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Dioxus is heavily inspired by React. If you know React, getting started with Dioxus will be a breeze.</p>
<blockquote>
<p>This guide assumes you already know some <a href="https://www.rust-lang.org/">Rust</a>! If not, we recommend reading <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html"><em>the book</em></a> to learn Rust first.</p>
</blockquote>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Desktop apps running natively (no Electron!) in less than 10 lines of code.</li>
<li>Incredibly ergonomic and powerful state management.</li>
<li>Comprehensive inline documentation – hover and guides for all HTML elements, listeners, and events.</li>
<li>Extremely memory efficient – 0 global allocations for steady-state components.</li>
<li>Multi-channel asynchronous scheduler for first-class async support.</li>
<li>And more! Read the <a href="https://dioxuslabs.com/blog/introducing-dioxus/">full release post</a>.</li>
</ul>
<h3 id="multiplatform"><a class="header" href="#multiplatform">Multiplatform</a></h3>
<p>Dioxus is a <em>portable</em> toolkit, meaning the Core implementation can run anywhere with no platform-dependent linking. Unlike many other Rust frontend toolkits, Dioxus is not intrinsically linked to WebSys. In fact, every element and event listener can be swapped out at compile time. By default, Dioxus ships with the <code>html</code> feature enabled, but this can be disabled depending on your target renderer.</p>
<p>Right now, we have several 1st-party renderers:</p>
<ul>
<li>WebSys (for WASM): Great support</li>
<li>Tao/Tokio (for Desktop apps): Good support</li>
<li>Tao/Tokio (for Mobile apps): Poor support</li>
<li>SSR (for generating static markup)</li>
<li>TUI/Rink (for terminal-based apps): Experimental</li>
</ul>
<h2 id="stability"><a class="header" href="#stability">Stability</a></h2>
<p>Dioxus has not reached a stable release yet.</p>
<p>Web: Since the web is a fairly mature platform, we expect there to be very little API churn for web-based features.</p>
<p>Desktop: APIs will likely be in flux as we figure out better patterns than our ElectronJS counterpart.</p>
<p>SSR: We don't expect the SSR API to change drastically in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section will help you set up your Dioxus project!</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="an-editor"><a class="header" href="#an-editor">An Editor</a></h3>
<p>Dioxus integrates very well with the <a href="https://rust-analyzer.github.io">Rust-Analyzer LSP plugin</a> which will provide appropriate syntax highlighting, code navigation, folding, and more.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Head over to <a href="http://rust-lang.org">https://rust-lang.org</a> and install the Rust compiler.</p>
<p>We strongly recommend going through the <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">official Rust book</a> <em>completely</em>. However, we hope that a Dioxus app can serve as a great first Rust project. With Dioxus, you'll learn about:</p>
<ul>
<li>Error handling</li>
<li>Structs, Functions, Enums</li>
<li>Closures</li>
<li>Macros</li>
</ul>
<p>We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.</p>
<h2 id="setup-guides"><a class="header" href="#setup-guides">Setup Guides</a></h2>
<p>Dioxus supports multiple platforms. Choose the platform you want to target below to get platform-specific setup instructions:</p>
<ul>
<li><a href="getting_started/web.html">Web</a>: runs in the browser through WebAssembly</li>
<li><a href="getting_started/ssr.html">Server Side Rendering</a>: renders to HTML text on the server</li>
<li><a href="getting_started/liveview.html">Liveview</a>: runs on the server, renders in the browser using WebSockets</li>
<li><a href="getting_started/desktop.html">Desktop</a>: runs in a web view on desktop</li>
<li><a href="getting_started/mobile.html">Mobile</a>: runs in a web view on mobile</li>
<li><a href="getting_started/tui.html">Terminal UI</a>: renders text-based graphics in the terminal</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="desktop-overview"><a class="header" href="#desktop-overview">Desktop Overview</a></h1>
<p>Build a standalone native desktop app that looks and feels the same across operating systems.</p>
<p>Apps built with Dioxus are typically &lt;5mb in size and use existing system resources, so they won't hog extreme amounts of RAM or memory.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/DioxusLabs/example-projects/blob/master/file-explorer">File Explorer</a></li>
<li><a href="https://github.com/DioxusLabs/example-projects/blob/master/wifi-scanner">WiFi Scanner</a></li>
</ul>
<p><a href="https://github.com/DioxusLabs/example-projects/tree/master/file-explorer"><img src="https://raw.githubusercontent.com/DioxusLabs/example-projects/master/file-explorer/image.png" alt="File ExplorerExample" /></a></p>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>The desktop is a powerful target for Dioxus but is currently limited in capability when compared to the Web platform. Currently, desktop apps are rendered with the platform's WebView library, but your Rust code is running natively on a native thread. This means that browser APIs are <em>not</em> available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs <em>are</em> accessible, so streaming, WebSockets, filesystem, etc are all viable APIs. In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations.</p>
<p>Dioxus Desktop is built off <a href="https://tauri.app/">Tauri</a>. Right now there aren't any Dioxus abstractions over the menubar, handling, etc, so you'll want to leverage Tauri – mostly <a href="http://github.com/tauri-apps/wry/">Wry</a> and <a href="http://github.com/tauri-apps/tao">Tao</a>) directly.</p>
<h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h1>
<h2 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform-Specific Dependencies</a></h2>
<p>Dioxus desktop renders through a web view. Depending on your platform, you might need to install some dependancies.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Windows Desktop apps depend on WebView2 – a library that should be installed in all modern Windows distributions. If you have Edge installed, then Dioxus will work fine. If you <em>don't</em> have Webview2, <a href="https://developer.microsoft.com/en-us/microsoft-edge/webview2/">then you can install it through Microsoft</a>. MS provides 3 options:</p>
<ol>
<li>A tiny &quot;evergreen&quot; <em>bootstrapper</em> that fetches an installer from Microsoft's CDN</li>
<li>A tiny <em>installer</em> that fetches Webview2 from Microsoft's CDN</li>
<li>A statically linked version of Webview2 in your final binary for offline users</li>
</ol>
<p>For development purposes, use Option 1.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Webview Linux apps require WebkitGtk. When distributing, this can be part of your dependency tree in your <code>.rpm</code> or <code>.deb</code>. However, likely, your users will already have WebkitGtk.</p>
<pre><code class="language-bash">sudo apt install libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev
</code></pre>
<p>When using Debian/bullseye <code>libappindicator3-dev</code> is no longer available but replaced by <code>libayatana-appindicator3-dev</code>.</p>
<pre><code class="language-bash"># on Debian/bullseye use:
sudo apt install libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev
</code></pre>
<p>If you run into issues, make sure you have all the basics installed, as outlined in the <a href="https://tauri.studio/v1/guides/getting-started/prerequisites#setting-up-linux">Tauri docs</a>.</p>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<p>Currently – everything for macOS is built right in! However, you might run into an issue if you're using nightly Rust due to some permissions issues in our Tao dependency (which have been resolved but not published).</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a Project</a></h2>
<p>Create a new crate:</p>
<pre><code class="language-shell">cargo new --bin demo
cd demo
</code></pre>
<p>Add Dioxus and the desktop renderer as dependencies (this will edit your <code>Cargo.toml</code>):</p>
<pre><code class="language-shell">cargo add dioxus
cargo add dioxus-desktop
</code></pre>
<p>Edit your <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the dioxus app in a webview
    dioxus_desktop::launch(App);
}

// define a component that renders a div with the text &quot;Hello, world!&quot;
fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web"><a class="header" href="#web">Web</a></h1>
<p>Build single-page applications that run in the browser with Dioxus. To run on the Web, your app must be compiled to WebAssembly and depend on the <code>dioxus</code> and <code>dioxus-web</code> crates.</p>
<p>A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">WebAssembly can be compiled as it is streamed</a>.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/DioxusLabs/example-projects/tree/master/todomvc">TodoMVC</a></li>
<li><a href="https://github.com/DioxusLabs/example-projects/tree/master/ecommerce-site">ECommerce</a></li>
</ul>
<p><a href="https://github.com/DioxusLabs/example-projects/blob/master/todomvc"><img src="https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png" alt="TodoMVC example" /></a></p>
<blockquote>
<p>Note: Because of the limitations of Wasm, <a href="https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html">not every crate will work</a> with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).</p>
</blockquote>
<h2 id="support-1"><a class="header" href="#support-1">Support</a></h2>
<p>The Web is the best-supported target platform for Dioxus.</p>
<ul>
<li>Because your app will be compiled to WASM you have access to browser APIs through <a href="https://rustwasm.github.io/docs/wasm-bindgen/introduction.html">wasm-bingen</a>.</li>
<li>Dioxus provides hydration to resume apps that are rendered on the server. See the <a href="getting_started/fullstack.html">fullstack</a> getting started guide for more information.</li>
</ul>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<p>To develop your Dioxus app for the web, you'll need a tool to build and serve your assets. We recommend using <a href="https://github.com/DioxusLabs/cli">dioxus-cli</a> which includes a build system, Wasm optimization, a dev server, and support hot reloading:</p>
<pre><code class="language-shell">cargo install dioxus-cli
</code></pre>
<p>Make sure the <code>wasm32-unknown-unknown</code> target for rust is installed:</p>
<pre><code class="language-shell">rustup target add wasm32-unknown-unknown
</code></pre>
<h2 id="creating-a-project-1"><a class="header" href="#creating-a-project-1">Creating a Project</a></h2>
<p>Create a new crate:</p>
<pre><code class="language-shell">cargo new --bin demo
cd demo
</code></pre>
<p>Add Dioxus and the web renderer as dependencies (this will edit your <code>Cargo.toml</code>):</p>
<pre><code class="language-bash">cargo add dioxus
cargo add dioxus-web
</code></pre>
<p>Edit your <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the web app
    dioxus_web::launch(App);
}

// create a component that renders a div with the text &quot;Hello, world!&quot;
fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
</code></pre></pre>
<p>And to serve our app:</p>
<pre><code class="language-bash">dioxus serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering"><a class="header" href="#server-side-rendering">Server-Side Rendering</a></h1>
<p>For lower-level control over the rendering process, you can use the <code>dioxus-ssr</code> crate directly. This can be useful when integrating with a web framework that <code>dioxus-server</code> does not support, or pre-rendering pages.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>For this guide, we're going to show how to use Dioxus SSR with <a href="https://docs.rs/axum/latest/axum/">Axum</a>.</p>
<p>Make sure you have Rust and Cargo installed, and then create a new project:</p>
<pre><code class="language-shell">cargo new --bin demo
cd demo
</code></pre>
<p>Add Dioxus and the ssr renderer as dependencies:</p>
<pre><code class="language-shell">cargo add dioxus
cargo add dioxus-ssr
</code></pre>
<p>Next, add all the Axum dependencies. This will be different if you're using a different Web Framework</p>
<pre><code>cargo add tokio --features full
cargo add axum
</code></pre>
<p>Your dependencies should look roughly like this:</p>
<pre><code class="language-toml">[dependencies]
axum = &quot;0.4.5&quot;
dioxus = { version = &quot;*&quot; }
dioxus-ssr = { version = &quot;*&quot; }
tokio = { version = &quot;1.15.0&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>Now, set up your Axum app to respond on an endpoint.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case)]
use axum::{response::Html, routing::get, Router};
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
    println!(&quot;listening on http://{}&quot;, addr);

    axum::Server::bind(&amp;addr)
        .serve(
            Router::new()
                .route(&quot;/&quot;, get(app_endpoint))
                .into_make_service(),
        )
        .await
        .unwrap();
}

</code></pre></pre>
<p>And then add our endpoint. We can either render <code>rsx!</code> directly:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn app_endpoint() -&gt; Html&lt;String&gt; {
    // render the rsx! macro to HTML
    Html(dioxus_ssr::render_lazy(rsx! {
        div { &quot;hello world!&quot; }
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Or we can render VirtualDoms.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn second_app_endpoint() -&gt; Html&lt;String&gt; {
    // create a component that renders a div with the text &quot;hello world&quot;
    fn app(cx: Scope) -&gt; Element {
        cx.render(rsx!(div { &quot;hello world&quot; }))
    }
    // create a VirtualDom with the app component
    let mut app = VirtualDom::new(app);
    // rebuild the VirtualDom before rendering
    let _ = app.rebuild();

    // render the VirtualDom to HTML
    Html(dioxus_ssr::render(&amp;app))
}
<span class="boring">}
</span></code></pre></pre>
<p>And then add our app component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// define a component that renders a div with the text &quot;Hello, world!&quot;
fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>And that's it!</p>
<h2 id="multithreaded-support"><a class="header" href="#multithreaded-support">Multithreaded Support</a></h2>
<p>The Dioxus VirtualDom, sadly, is not currently <code>Send</code>. Internally, we use quite a bit of interior mutability which is not thread-safe.
When working with web frameworks that require <code>Send</code>, it is possible to render a VirtualDom immediately to a String – but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to spawn a VirtualDom on its own thread and communicate with it via channels or create a pool of VirtualDoms.
You might notice that you cannot hold the VirtualDom across an await point. Because Dioxus is currently not ThreadSafe, it <em>must</em> remain on the thread it started. We are working on loosening this requirement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fullstack"><a class="header" href="#fullstack">Fullstack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liveview"><a class="header" href="#liveview">Liveview</a></h1>
<p>Liveview allows apps to <em>run</em> on the server and <em>render</em> in the browser. It uses WebSockets to communicate between the server and the browser.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/axum.rs">Axum Example</a></li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/salvo.rs">Salvo Example</a></li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/warp.rs">Warp Example</a></li>
</ul>
<h2 id="support-2"><a class="header" href="#support-2">Support</a></h2>
<p>Liveview is currently limited in capability when compared to the Web platform. Liveview apps run on the server in a native thread. This means that browser APIs are not available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs are accessible, so streaming, WebSockets, filesystem, etc are all viable APIs.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>For this guide, we're going to show how to use Dioxus Liveview with <a href="https://docs.rs/axum/latest/axum/">Axum</a>.</p>
<p>Make sure you have Rust and Cargo installed, and then create a new project:</p>
<pre><code class="language-shell">cargo new --bin demo
cd app
</code></pre>
<p>Add Dioxus and the liveview renderer with the Axum feature as dependencies:</p>
<pre><code class="language-shell">cargo add dioxus
cargo add dioxus-liveview --features axum
</code></pre>
<p>Next, add all the Axum dependencies. This will be different if you're using a different Web Framework</p>
<pre><code>cargo add tokio --features full
cargo add axum
</code></pre>
<p>Your dependencies should look roughly like this:</p>
<pre><code class="language-toml">[dependencies]
axum = &quot;0.4.5&quot;
dioxus = { version = &quot;*&quot; }
dioxus-liveview = { version = &quot;*&quot;, features = [&quot;axum&quot;] }
tokio = { version = &quot;1.15.0&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>Now, set up your Axum app to respond on an endpoint.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#[tokio::main]
async fn main() {
    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3030).into();

    let view = dioxus_liveview::LiveViewPool::new();

    let app = Router::new()
        // The root route contains the glue code to connect to the WebSocket
        .route(
            &quot;/&quot;,
            get(move || async move {
                Html(format!(
                    r#&quot;
                &lt;!DOCTYPE html&gt;
                &lt;html&gt;
                &lt;head&gt; &lt;title&gt;Dioxus LiveView with Axum&lt;/title&gt;  &lt;/head&gt;
                &lt;body&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt; &lt;/body&gt;
                {glue}
                &lt;/html&gt;
                &quot;#,
                    // Create the glue code to connect to the WebSocket on the &quot;/ws&quot; route
                    glue = dioxus_liveview::interpreter_glue(&amp;format!(&quot;ws://{addr}/ws&quot;))
                ))
            }),
        )
        // The WebSocket route is what Dioxus uses to communicate with the browser
        .route(
            &quot;/ws&quot;,
            get(move |ws: WebSocketUpgrade| async move {
                ws.on_upgrade(move |socket| async move {
                    // When the WebSocket is upgraded, launch the LiveView with the app component
                    _ = view.launch(dioxus_liveview::axum_socket(socket), app).await;
                })
            }),
        );

    println!(&quot;Listening on http://{addr}&quot;);

    axum::Server::bind(&amp;addr.to_string().parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
</code></pre></pre>
<p>And then add our app component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>And that's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal-ui"><a class="header" href="#terminal-ui">Terminal UI</a></h1>
<p>You can build a text-based interface that will run in the terminal using Dioxus.</p>
<p><img src="https://github.com/DioxusLabs/rink/raw/master/examples/example.png" alt="Hello World screenshot" /></p>
<blockquote>
<p>Note: this book was written with HTML-based platforms in mind. You might be able to follow along with TUI, but you'll have to adapt a bit.</p>
</blockquote>
<h2 id="support-3"><a class="header" href="#support-3">Support</a></h2>
<p>TUI support is currently quite experimental. But, if you're willing to venture into the realm of the unknown, this guide will get you started.</p>
<ul>
<li>It uses flexbox for the layout</li>
<li>It only supports a subset of the attributes and elements</li>
<li>Regular widgets will not work in the tui render, but the tui renderer has its own widget components that start with a capital letter. See the <a href="https://github.com/DioxusLabs/dioxus/blob/master/packages/dioxus-tui/examples/widgets.rs">widgets example</a></li>
<li>1px is one character line height. Your regular CSS px does not translate</li>
<li>If your app panics, your terminal is wrecked. This will be fixed eventually</li>
</ul>
<h2 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set up</a></h2>
<p>Start by making a new package and adding Dioxus and the TUI renderer as dependancies.</p>
<pre><code class="language-shell">cargo new --bin demo
cd demo
cargo add dioxus
cargo add dioxus-tui
</code></pre>
<p>Then, edit your <code>main.rs</code> with the basic template.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the app in the terminal
    dioxus_tui::launch(App);
}

// create a component that renders a div with the text &quot;Hello, world!&quot;
fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
</code></pre></pre>
<p>To run our app:</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>Press &quot;ctrl-c&quot; to close the app. To switch from &quot;ctrl-c&quot; to just &quot;q&quot; to quit you can launch the app with a configuration to disable the default quit and use the root TuiContext to quit on your own.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// todo remove deprecated
#![allow(non_snake_case, deprecated)]

use dioxus::events::{KeyCode, KeyboardEvent};
use dioxus::prelude::*;
use dioxus_tui::TuiContext;

fn main() {
    dioxus_tui::launch_cfg(
        App,
        dioxus_tui::Config::new()
            .without_ctrl_c_quit()
            // Some older terminals only support 16 colors or ANSI colors
            // If your terminal is one of these, change this to BaseColors or ANSI
            .with_rendering_mode(dioxus_tui::RenderingMode::Rgb),
    );
}

fn App(cx: Scope) -&gt; Element {
    let tui_ctx: TuiContext = cx.consume_context().unwrap();

    cx.render(rsx! {
        div {
            width: &quot;100%&quot;,
            height: &quot;10px&quot;,
            background_color: &quot;red&quot;,
            justify_content: &quot;center&quot;,
            align_items: &quot;center&quot;,
            onkeydown: move |k: KeyboardEvent| if let KeyCode::Q = k.key_code {
                tui_ctx.quit();
            },

            &quot;Hello world!&quot;
        }
    })
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mobile-app"><a class="header" href="#mobile-app">Mobile App</a></h1>
<p>Build a mobile app with Dioxus!</p>
<p>Example: <a href="https://github.com/DioxusLabs/example-projects/blob/master/ios_demo">Todo App</a></p>
<h2 id="support-4"><a class="header" href="#support-4">Support</a></h2>
<p>Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with either the platform's WebView or experimentally through <a href="https://github.com/DioxusLabs/blitz">WGPU</a>. WebView doesn't support animations, transparency, and native widgets.</p>
<p>Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.</p>
<p>This guide is primarily targeted at iOS apps, however, you can follow it while using the <code>android</code> guide in <code>cargo-mobile</code>.</p>
<h2 id="getting-set-up-1"><a class="header" href="#getting-set-up-1">Getting Set up</a></h2>
<p>Getting set up with mobile can be quite challenging. The tooling here isn't great (yet) and might take some hacking around to get things working. macOS M1 is broadly unexplored and might not work for you.</p>
<p>We're going to be using <code>cargo-mobile</code> to build for mobile. First, install it:</p>
<pre><code class="language-shell">cargo install --git https://github.com/BrainiumLLC/cargo-mobile
</code></pre>
<p>And then initialize your app for the right platform. Use the <code>winit</code> template for now. Right now, there's no &quot;Dioxus&quot; template in cargo-mobile.</p>
<pre><code class="language-shell">cargo mobile init
</code></pre>
<p>We're going to completely clear out the <code>dependencies</code> it generates for us, swapping out <code>winit</code> with <code>dioxus-mobile</code>.</p>
<pre><code class="language-toml">
[package]
name = &quot;dioxus-ios-demo&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;


# leave the `lib` declaration
[lib]
crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;, &quot;rlib&quot;]


# leave the binary it generates for us
[[bin]]
name = &quot;dioxus-ios-demo-desktop&quot;
path = &quot;gen/bin/desktop.rs&quot;

# clear all the dependencies
[dependencies]
mobile-entry-point = &quot;0.1.0&quot;
dioxus = { version = &quot;*&quot;}
dioxus-desktop = { version = &quot;*&quot; }
simple_logger = &quot;*&quot;
</code></pre>
<p>Edit your <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -&gt; Element {
    cx.render(rsx!{
        div {
            &quot;hello world!&quot;
        }
    })
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-hot-reload"><a class="header" href="#setting-up-hot-reload">Setting Up Hot Reload</a></h1>
<ol>
<li>Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.</li>
<li>It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.</li>
<li>Currently the cli only implements hot reloading for the web renderer. For TUI, desktop, and LiveView you can use the hot reload macro instead.</li>
</ol>
<h1 id="web-1"><a class="header" href="#web-1">Web</a></h1>
<p>For the web renderer, you can use the dioxus cli to serve your application with hot reloading enabled.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>Install <a href="https://github.com/DioxusLabs/cli">dioxus-cli</a>.
Hot reloading is automatically enabled when using the web renderer on debug builds.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<ol>
<li>Run:</li>
</ol>
<pre><code class="language-bash">dioxus serve --hot-reload
</code></pre>
<ol start="2">
<li>Change some code within a rsx or render macro</li>
<li>Open your localhost in a browser</li>
<li>Save and watch the style change without recompiling</li>
</ol>
<h1 id="desktopliveviewtuiserver"><a class="header" href="#desktopliveviewtuiserver">Desktop/Liveview/TUI/Server</a></h1>
<p>For desktop, LiveView, and tui, you can place the hot reload macro at the top of your main function to enable hot reloading.
Hot reloading is automatically enabled on debug builds.</p>
<p>For more information about hot reloading on native platforms and configuration options see the <a href="https://crates.io/crates/dioxus-hot-reload">dioxus-hot-reload</a> crate.</p>
<h2 id="setup-3"><a class="header" href="#setup-3">Setup</a></h2>
<p>Add the following to your main function:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    hot_reload_init!();
    // launch your application
}
</code></pre></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<ol>
<li>Run:</li>
</ol>
<pre><code class="language-bash">cargo run
</code></pre>
<ol start="2">
<li>Change some code within a rsx or render macro</li>
<li>Save and watch the style change without recompiling</li>
</ol>
<h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<ol>
<li>The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.</li>
<li>Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="describing-the-ui"><a class="header" href="#describing-the-ui">Describing the UI</a></h1>
<p>Dioxus is a <em>declarative</em> framework. This means that instead of telling Dioxus what to do (e.g. to &quot;create an element&quot; or &quot;set the color to red&quot;) we simply <em>declare</em> what we want the UI to look like using RSX.</p>
<p>You have already seen a simple example of RSX syntax in the &quot;hello world&quot; application:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// define a component that renders a div with the text &quot;Hello, world!&quot;
fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we use the <code>rsx!</code> macro to <em>declare</em> that we want a <code>div</code> element, containing the text <code>&quot;Hello, world!&quot;</code>. Dioxus takes the RSX and constructs a UI from it.</p>
<h2 id="rsx-features"><a class="header" href="#rsx-features">RSX Features</a></h2>
<p>RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty <code>div</code> element in RSX, as well as the resulting HTML:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!(div {
    // attributes / listeners
    // children
}))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
</code></pre>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Attributes (and <a href="describing_ui/../interactivity/index.html">listeners</a>) modify the behavior or appearance of the element they are attached to. They are specified inside the <code>{}</code> brackets, using the <code>name: value</code> syntax. You can provide the value as a literal in the RSX:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!(a {
    href: &quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;,
    class: &quot;primary_button&quot;,
    color: &quot;red&quot;,
}))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;a href=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot; class=&quot;primary_button&quot; autofocus=&quot;true&quot; style=&quot;color: red&quot;&gt;&lt;/a&gt;
</code></pre>
<blockquote>
<p>Note: All attributes defined in <code>dioxus-html</code> follow the snake_case naming convention. They transform their <code>snake_case</code> names to HTML's <code>camelCase</code> attributes.</p>
</blockquote>
<blockquote>
<p>Note: Styles can be used directly outside of the <code>style:</code> attribute. In the above example, <code>color: &quot;red&quot;</code> is turned into <code>style=&quot;color: red&quot;</code>.</p>
</blockquote>
<h4 id="custom-attributes"><a class="header" href="#custom-attributes">Custom Attributes</a></h4>
<p>Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    cx.render(rsx!(b {
        &quot;customAttribute&quot;: &quot;value&quot;,
    }))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;b customAttribute=&quot;value&quot;&gt;
&lt;/b&gt;
</code></pre>
<h3 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h3>
<p>Similarly to how you can <a href="https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html">format</a> Rust strings, you can also interpolate in RSX text. Use <code>{variable}</code> to Display the value of a variable in a string, or <code>{variable:?}</code> to use the Debug representation:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let coordinates = (42, 0);
let country = &quot;es&quot;;
cx.render(rsx!(div {
    class: &quot;country-{country}&quot;,
    &quot;position&quot;: &quot;{coordinates:?}&quot;,
    // arbitrary expressions are allowed,
    // as long as they don't contain `{}`
    div {
        &quot;{country.to_uppercase()}&quot;
    },
    div {
        &quot;{7*6}&quot;
    },
    // {} can be escaped with {{}}
    div {
        &quot;{{}}&quot;
    },
}))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;div class=&quot;country-es&quot; position=&quot;(42, 0)&quot;&gt;
    &lt;div&gt;ES&lt;/div&gt;
    &lt;div&gt;42&lt;/div&gt;
    &lt;div&gt;{}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="children"><a class="header" href="#children">Children</a></h3>
<p>To add children to an element, put them inside the <code>{}</code> brackets after all attributes and listeners in the element. They can be other elements, text, or <a href="describing_ui/components.html">components</a>. For example, you could have an <code>ol</code> (ordered list) element, containing 3 <code>li</code> (list item) elements, each of which contains some text:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!(ol {
    li {&quot;First Item&quot;}
    li {&quot;Second Item&quot;}
    li {&quot;Third Item&quot;}
}))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;ol&gt;
    &lt;li&gt;First Item&lt;/li&gt;
    &lt;li&gt;Second Item&lt;/li&gt;
    &lt;li&gt;Third Item&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<h3 id="fragments"><a class="header" href="#fragments">Fragments</a></h3>
<p>You can render multiple elements at the top level of <code>rsx!</code> and they will be automatically grouped.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!(
    p {&quot;First Item&quot;},
    p {&quot;Second Item&quot;},
))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;p&gt;First Item&lt;/p&gt;
&lt;p&gt;Second Item&lt;/p&gt;
</code></pre>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>You can include arbitrary Rust expressions as children within RSX that implements <a href="https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html">IntoDynNode</a>. This is useful for displaying data from an <a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators">iterator</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let text = &quot;Dioxus&quot;;
cx.render(rsx!(span {
    text.to_uppercase(),
    // create a list of text from 0 to 9
    (0..10).map(|i| rsx!{ i.to_string() })
}))
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;span&gt;DIOXUS0123456789&lt;/span&gt;
</code></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<p>In addition to iterators you can also use for loops directly within RSX:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!{
    // use a for loop where the body itself is RSX
    div {
        // create a list of text from 0 to 9
        for i in 0..3 {
            // NOTE: the body of the loop is RSX not a rust statement
            div {
                &quot;{i}&quot;
            }
        }
    }
    // iterator equivalent
    div {
        (0..3).map(|i| rsx!{ div { &quot;{i}&quot; } })
    }
})
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;div&gt;0&lt;/div&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2&lt;/div&gt;
&lt;div&gt;0&lt;/div&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2&lt;/div&gt;
</code></pre>
<h3 id="if-statements"><a class="header" href="#if-statements">If statements</a></h3>
<p>You can also use if statements without an else branch within RSX:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!{
    // use if statements without an else
    if true {
        rsx!(div { &quot;true&quot; })
    }
})
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;div&gt;true&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-attributes"><a class="header" href="#special-attributes">Special Attributes</a></h1>
<p>While most attributes are simply passed on to the HTML, some have special behaviors.</p>
<h2 id="the-html-escape-hatch"><a class="header" href="#the-html-escape-hatch">The HTML Escape Hatch</a></h2>
<p>If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for <code>dangerous_inner_html</code>.</p>
<p>For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the <a href="https://dioxuslabs.com">Dioxus homepage</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this should come from a trusted source
let contents = &quot;live &lt;b&gt;dangerously&lt;/b&gt;&quot;;

cx.render(rsx! {
    div {
        dangerous_inner_html: &quot;{contents}&quot;,
    }
})
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note! This attribute is called &quot;dangerous_inner_html&quot; because it is <strong>dangerous</strong> to pass it data you don't trust. If you're not careful, you can easily expose <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting (XSS)</a> attacks to your users.</p>
<p>If you're handling untrusted input, make sure to sanitize your HTML before passing it into <code>dangerous_inner_html</code> – or just pass it to a Text Element to escape any HTML tags.</p>
</blockquote>
<h2 id="boolean-attributes"><a class="header" href="#boolean-attributes">Boolean Attributes</a></h2>
<p>Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered &quot;boolean&quot; attributes and just their presence determines whether they affect the output. For these attributes, a provided value of <code>&quot;false&quot;</code> will cause them to be removed from the target element.</p>
<p>So this RSX wouldn't actually render the <code>hidden</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx! {
    div {
        hidden: &quot;false&quot;,
        &quot;hello&quot;
    }
})
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;div&gt;hello&lt;/div&gt;
</code></pre>
<p>Not all attributes work like this however. <em>Only the following attributes</em> have this behavior:</p>
<ul>
<li><code>allowfullscreen</code></li>
<li><code>allowpaymentrequest</code></li>
<li><code>async</code></li>
<li><code>autofocus</code></li>
<li><code>autoplay</code></li>
<li><code>checked</code></li>
<li><code>controls</code></li>
<li><code>default</code></li>
<li><code>defer</code></li>
<li><code>disabled</code></li>
<li><code>formnovalidate</code></li>
<li><code>hidden</code></li>
<li><code>ismap</code></li>
<li><code>itemscope</code></li>
<li><code>loop</code></li>
<li><code>multiple</code></li>
<li><code>muted</code></li>
<li><code>nomodule</code></li>
<li><code>novalidate</code></li>
<li><code>open</code></li>
<li><code>playsinline</code></li>
<li><code>readonly</code></li>
<li><code>required</code></li>
<li><code>reversed</code></li>
<li><code>selected</code></li>
<li><code>truespeed</code></li>
</ul>
<p>For any other attributes, a value of <code>&quot;false&quot;</code> will be sent directly to the DOM.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Just like you wouldn't want to write a complex program in a single, long, <code>main</code> function, you shouldn't build a complex UI in a single <code>App</code> function. Instead, you should break down the functionality of an app in logical parts called components.</p>
<p>A component is a Rust function, named in UpperCammelCase, that takes a <code>Scope</code> parameter and returns an <code>Element</code> describing the UI it wants to render. In fact, our <code>App</code> function is a component!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// define a component that renders a div with the text &quot;Hello, world!&quot;
fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;Hello, world!&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You'll probably want to add <code>#![allow(non_snake_case)]</code> to the top of your crate to avoid warnings about UpperCammelCase component names</p>
</blockquote>
<p>A Component is responsible for some rendering task – typically, rendering an isolated part of the user interface. For example, you could have an <code>About</code> component that renders a short description of Dioxus Labs:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn About(cx: Scope) -&gt; Element {
    cx.render(rsx!(p {
        b {&quot;Dioxus Labs&quot;}
        &quot; An Open Source project dedicated to making Rust UI wonderful.&quot;
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, you can render your component in another component, similarly to how elements are rendered:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        About {},
        About {},
    })
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="describing_ui/./images/screenshot_about_component.png" alt="Screenshot containing the About component twice" /></p>
<blockquote>
<p>At this point, it might seem like components are nothing more than functions. However, as you learn more about the features of Dioxus, you'll see that they are actually more powerful!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-props"><a class="header" href="#component-props">Component Props</a></h1>
<p>Just like you can pass arguments to a function, you can pass props to a component that customize its behavior! The components we've seen so far didn't accept any props – so let's write some components that do.</p>
<h2 id="deriveprops"><a class="header" href="#deriveprops"><code>#[derive(Props)]</code></a></h2>
<p>Component props are a single struct annotated with <code>#[derive(Props)]</code>. For a component to accept props, the type of its argument must be <code>Scope&lt;YourPropsStruct&gt;</code>. Then, you can access the value of the props using <code>cx.props</code>.</p>
<p>There are 2 flavors of Props structs:</p>
<ul>
<li>Owned props:
<ul>
<li>Don't have an associated lifetime</li>
<li>Implement <code>PartialEq</code>, allow for memoization (if the props don't change, Dioxus won't re-render the component)</li>
</ul>
</li>
<li>Borrowed props:
<ul>
<li><a href="https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html">Borrow</a> from a parent component</li>
<li>Cannot be memoized due to lifetime constraints</li>
</ul>
</li>
</ul>
<h3 id="owned-props"><a class="header" href="#owned-props">Owned Props</a></h3>
<p>Owned Props are very simple – they don't borrow anything. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remember: Owned props must implement `PartialEq`!
#[derive(PartialEq, Props)]
struct LikesProps {
    score: i32,
}

fn Likes(cx: Scope&lt;LikesProps&gt;) -&gt; Element {
    cx.render(rsx! {
        div {
            &quot;This post has &quot;,
            b { &quot;{cx.props.score}&quot; },
            &quot; likes&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>You can then pass prop values to the component the same way you would pass attributes to an element:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        Likes {
            score: 42,
        },
    })
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="describing_ui/./images/component_owned_props_screenshot.png" alt="Screenshot: Likes component" /></p>
<h3 id="borrowed-props"><a class="header" href="#borrowed-props">Borrowed Props</a></h3>
<p>Owned props work well if your props are easy to copy around – like a single number. But what if we need to pass a larger data type, like a String from an <code>App</code> Component to a <code>TitleCard</code> subcomponent? A naive solution might be to <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>.clone()</code></a> the String, creating a copy of it for the subcomponent – but this would be inefficient, especially for larger Strings.</p>
<p>Rust allows for something more efficient – borrowing the String as a <code>&amp;str</code> – this is what Borrowed Props are for!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct TitleCardProps&lt;'a&gt; {
    title: &amp;'a str,
}

fn TitleCard&lt;'a&gt;(cx: Scope&lt;'a, TitleCardProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx! {
        h1 { &quot;{cx.props.title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>We can then use the component like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    let hello = &quot;Hello Dioxus!&quot;;

    cx.render(rsx!(TitleCard { title: hello }))
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="describing_ui/./images/component_borrowed_props_screenshot.png" alt="Screenshot: TitleCard component" /></p>
<p>Borrowed props can be very useful, but they do not allow for memorization so they will <em>always</em> rerun when the parent scope is rerendered. Because of this Borrowed Props should be reserved for components that are cheap to rerun or places where cloning data is an issue. Using Borrowed Props everywhere will result in large parts of your app rerunning every interaction.</p>
<h2 id="prop-options"><a class="header" href="#prop-options">Prop Options</a></h2>
<p>The <code>#[derive(Props)]</code> macro has some features that let you customize the behavior of props.</p>
<h3 id="optional-props"><a class="header" href="#optional-props">Optional Props</a></h3>
<p>You can create optional fields by using the <code>Option&lt;…&gt;</code> type for a field:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct OptionalProps&lt;'a&gt; {
    title: &amp;'a str,
    subtitle: Option&lt;&amp;'a str&gt;,
}

fn Title&lt;'a&gt;(cx: Scope&lt;'a, OptionalProps&gt;) -&gt; Element&lt;'a&gt; {
    cx.render(rsx!(h1{
        &quot;{cx.props.title}: &quot;,
        cx.props.subtitle.unwrap_or(&quot;No subtitle provided&quot;),
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, you can choose to either provide them or not:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Title {
    title: &quot;Some Title&quot;,
},
Title {
    title: &quot;Some Title&quot;,
    subtitle: &quot;Some Subtitle&quot;,
},
// Providing an Option explicitly won't compile though:
// Title {
//     title: &quot;Some Title&quot;,
//     subtitle: None,
// },
<span class="boring">}
</span></code></pre></pre>
<h3 id="explicitly-required-options"><a class="header" href="#explicitly-required-options">Explicitly Required <code>Option</code>s</a></h3>
<p>If you want to explicitly require an <code>Option</code>, and not an optional prop, you can annotate it with <code>#[props(!optional)]</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ExplicitOptionProps&lt;'a&gt; {
    title: &amp;'a str,
    #[props(!optional)]
    subtitle: Option&lt;&amp;'a str&gt;,
}

fn ExplicitOption&lt;'a&gt;(cx: Scope&lt;'a, ExplicitOptionProps&gt;) -&gt; Element&lt;'a&gt; {
    cx.render(rsx!(h1 {
        &quot;{cx.props.title}: &quot;,
        cx.props.subtitle.unwrap_or(&quot;No subtitle provided&quot;),
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, you have to explicitly pass either <code>Some(&quot;str&quot;)</code> or <code>None</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ExplicitOption {
    title: &quot;Some Title&quot;,
    subtitle: None,
},
ExplicitOption {
    title: &quot;Some Title&quot;,
    subtitle: Some(&quot;Some Title&quot;),
},
// This won't compile:
// ExplicitOption {
//     title: &quot;Some Title&quot;,
// },
<span class="boring">}
</span></code></pre></pre>
<h3 id="default-props"><a class="header" href="#default-props">Default Props</a></h3>
<p>You can use <code>#[props(default = 42)]</code> to make a field optional and specify its default value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Props)]
struct DefaultProps {
    // default to 42 when not provided
    #[props(default = 42)]
    number: i64,
}

fn DefaultComponent(cx: Scope&lt;DefaultProps&gt;) -&gt; Element {
    cx.render(rsx!(h1 { &quot;{cx.props.number}&quot; }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, similarly to optional props, you don't have to provide it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DefaultComponent {
    number: 5,
},
DefaultComponent {},
<span class="boring">}
</span></code></pre></pre>
<h3 id="automatic-conversion-with-into"><a class="header" href="#automatic-conversion-with-into">Automatic Conversion with <code>.into</code></a></h3>
<p>It is common for Rust functions to accept <code>impl Into&lt;SomeType&gt;</code> rather than just <code>SomeType</code> to support a wider range of parameters. If you want similar functionality with props, you can use <code>#[props(into)]</code>. For example, you could add it on a <code>String</code> prop – and <code>&amp;str</code> will also be automatically accepted, as it can be converted into <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Props)]
struct IntoProps {
    #[props(into)]
    string: String,
}

fn IntoComponent(cx: Scope&lt;IntoProps&gt;) -&gt; Element {
    cx.render(rsx!(h1 { &quot;{cx.props.string}&quot; }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, you can use it so:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>IntoComponent {
    string: &quot;some &amp;str&quot;,
},
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-inline_props-macro"><a class="header" href="#the-inline_props-macro">The <code>inline_props</code> macro</a></h2>
<p>So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing <code>cx.props.whatever</code>, we could just use <code>whatever</code> directly!</p>
<p><code>inline_props</code> allows you to do just that. Instead of typing the &quot;full&quot; version:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(cx: Scope&lt;TitleCardProps&gt;) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{cx.props.title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>...you can define a function that accepts props as arguments. Then, just annotate it with <code>#[inline_props]</code>, and the macro will turn it into a regular Component for you:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn TitleCard(cx: Scope, title: String) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-children"><a class="header" href="#component-children">Component Children</a></h1>
<p>In some cases, you may wish to create a component that acts as a container for some other content, without the component needing to know what that content is. To achieve this, create a prop of type <code>Element</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ClickableProps&lt;'a&gt; {
    href: &amp;'a str,
    body: Element&lt;'a&gt;,
}

fn Clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!(
        a {
            href: &quot;{cx.props.href}&quot;,
            class: &quot;fancy-button&quot;,
            &amp;cx.props.body
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, when rendering the component, you can pass in the output of <code>cx.render(rsx!(...))</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    cx.render(rsx! {
        Clickable {
            href: &quot;https://www.youtube.com/watch?v=C-M2hs3sXGo&quot;,
            body: cx.render(rsx!(&quot;How to &quot; i {&quot;not&quot;} &quot; be seen&quot;)),
        }
    })
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: Since <code>Element&lt;'a&gt;</code> is a borrowed prop, there will be no memoization.</p>
</blockquote>
<blockquote>
<p>Warning: While it may compile, do not include the same <code>Element</code> more than once in the RSX. The resulting behavior is unspecified.</p>
</blockquote>
<h2 id="the-children-field"><a class="header" href="#the-children-field">The <code>children</code> field</a></h2>
<p>Rather than passing the RSX through a regular prop, you may wish to accept children similarly to how elements can have children. The &quot;magic&quot; <code>children</code> prop lets you achieve this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ClickableProps&lt;'a&gt; {
    href: &amp;'a str,
    children: Element&lt;'a&gt;,
}

fn Clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!(
        a {
            href: &quot;{cx.props.href}&quot;,
            class: &quot;fancy-button&quot;,
            &amp;cx.props.children
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>This makes using the component much simpler: simply put the RSX inside the <code>{}</code> brackets – and there is no need for a <code>render</code> call or another macro!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    cx.render(rsx! {
        Clickable {
            href: &quot;https://www.youtube.com/watch?v=C-M2hs3sXGo&quot;,
            &quot;How to &quot; i {&quot;not&quot;} &quot; be seen&quot;
        }
    })
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interactivity"><a class="header" href="#interactivity">Interactivity</a></h1>
<p>So far, we've learned how to describe the structure and properties of our user interfaces. However, most interfaces need to be interactive in order to be useful. In this chapter, we describe how to make a Dioxus app that responds to the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h1>
<p>Event handlers are used to respond to user actions. For example, an event handler could be triggered when the user clicks, scrolls, moves the mouse, or types a character.</p>
<p>Event handlers are attached to elements. For example, we usually don't care about all the clicks that happen within an app, only those on a particular button.</p>
<p>Event handlers are similar to regular attributes, but their name usually starts with <code>on</code>- and they accept closures as values. The closure will be called whenever the event it listens for is triggered and will be passed that event.</p>
<p>For example, to handle clicks on an element, we can specify an <code>onclick</code> handler:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx! {
    button {
        onclick: move |event| println!(&quot;Clicked! Event: {event:?}&quot;),
        &quot;click me!&quot;
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-event-object"><a class="header" href="#the-event-object">The <code>Event</code> object</a></h2>
<p>Event handlers receive an <a href="https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html"><code>Event</code></a> object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain <a href="https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html"><code>MouseData</code></a>, which tells you things like where the mouse was clicked and what mouse buttons were used.</p>
<p>In the example above, this event data was logged to the terminal:</p>
<pre><code>Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
</code></pre>
<p>To learn what the different event types for HTML provide, read the <a href="https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html">events module docs</a>.</p>
<h3 id="event-propagation"><a class="header" href="#event-propagation">Event propagation</a></h3>
<p>Some events will trigger first on the element the event originated at upward. For example, a click event on a <code>button</code> inside a <code>div</code> would first trigger the button's event listener and then the div's event listener.</p>
<blockquote>
<p>For more information about event propigation see <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling">the mdn docs on event bubling</a></p>
</blockquote>
<p>If you want to prevent this behavior, you can call <code>stop_propagation()</code> on the event:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx! {
    div {
        onclick: move |_event| {},
        &quot;outer&quot;,
        button {
            onclick: move |event| {
                // now, outer won't be triggered
                event.stop_propagation();
            },
            &quot;inner&quot;
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="prevent-default"><a class="header" href="#prevent-default">Prevent Default</a></h2>
<p>Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text.</p>
<p>In some instances, might want to avoid this default behavior. For this, you can add the <code>prevent_default</code> attribute with the name of the handler whose default behavior you want to stop. This attribute can be used for multiple handlers using their name separated by spaces:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx! {
    input {
        prevent_default: &quot;oninput onclick&quot;,
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>Any event handlers will still be called.</p>
<blockquote>
<p>Normally, in React or JavaScript, you'd call &quot;preventDefault&quot; on the event in the callback. Dioxus does <em>not</em> currently support this behavior. Note: this means you cannot conditionally prevent default behavior based on the data in the event.</p>
</blockquote>
<h2 id="handler-props"><a class="header" href="#handler-props">Handler Props</a></h2>
<p>Sometimes, you might want to make a component that accepts an event handler. A simple example would be a <code>FancyButton</code> component, which accepts an <code>on_click</code> handler:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
pub struct FancyButtonProps&lt;'a&gt; {
    on_click: EventHandler&lt;'a, MouseEvent&gt;,
}

pub fn FancyButton&lt;'a&gt;(cx: Scope&lt;'a, FancyButtonProps&lt;'a&gt;&gt;) -&gt; Element&lt;'a&gt; {
    cx.render(rsx!(button {
        class: &quot;fancy-button&quot;,
        onclick: move |evt| cx.props.on_click.call(evt),
        &quot;click me pls.&quot;
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, you can use it like any other handler:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    cx.render(rsx! {
        FancyButton {
            on_click: move |event| println!(&quot;Clicked! {event:?}&quot;)
        }
    })
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: just like any other attribute, you can name the handlers anything you want! Though they must start with <code>on</code>, for the prop to be automatically turned into an <code>EventHandler</code> at the call site.</p>
<p>You can also put custom data in the event, rather than e.g. <code>MouseData</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks-and-component-state"><a class="header" href="#hooks-and-component-state">Hooks and Component State</a></h1>
<p>So far our components have had no state like a normal rust functions. However, in a UI component, it is often useful to have stateful functionality to build user interactions. For example, you might want to track whether the user has opened a drop-down, and render different things accordingly.</p>
<p>Hooks allow us to create state in our components. Hooks are Rust functions that take a reference to <code>ScopeState</code> (in a component, you can pass <code>cx</code>), and provide you with functionality and state.</p>
<h2 id="use_state-hook"><a class="header" href="#use_state-hook"><code>use_state</code> Hook</a></h2>
<p><a href="https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_state.html"><code>use_state</code></a> is one of the simplest hooks.</p>
<ul>
<li>You provide a closure that determines the initial value</li>
<li><code>use_state</code> gives you the current value, and a way to update it by setting it to something else</li>
<li>When the value updates, <code>use_state</code> makes the component re-render, and provides you with the new value</li>
</ul>
<p>For example, you might have seen the counter example, in which state (a number) is tracked using the <code>use_state</code> hook:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { &quot;High-Five counter: {count}&quot; }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count += 1
            },
            &quot;Up high!&quot;
        }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count -= 1
            },
            &quot;Down low!&quot;
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="interactivity/./images/counter.png" alt="Screenshot: counter app" /></p>
<p>Every time the component's state changes, it re-renders, and the component function is called, so you can describe what you want the new UI to look like. You don't have to worry about &quot;changing&quot; anything – just describe what you want in terms of the state, and Dioxus will take care of the rest!</p>
<blockquote>
<p><code>use_state</code> returns your value wrapped in a smart pointer of type <a href="https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html"><code>UseState</code></a>. This is why you can both read the value and update it, even within an event handler.</p>
</blockquote>
<p>You can use multiple hooks in the same component if you want:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    let mut count_a = use_state(cx, || 0);
    let mut count_b = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { &quot;Counter_a: {count_a}&quot; }
        button { onclick: move |_| count_a += 1, &quot;a++&quot; }
        button { onclick: move |_| count_a -= 1, &quot;a--&quot; }
        h1 { &quot;Counter_b: {count_b}&quot; }
        button { onclick: move |_| count_b += 1, &quot;b++&quot; }
        button { onclick: move |_| count_b -= 1, &quot;b--&quot; }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="interactivity/./images/counter_two_state.png" alt="Screenshot: app with two counters" /></p>
<h2 id="rules-of-hooks"><a class="header" href="#rules-of-hooks">Rules of Hooks</a></h2>
<p>The above example might seem a bit magic, since Rust functions are typically not associated with state. Dioxus allows hooks to maintain state across renders through a reference to <code>ScopeState</code>, which is why you must pass <code>&amp;cx</code> to them.</p>
<p>But how can Dioxus differentiate between multiple hooks in the same component? As you saw in the second example, both <code>use_state</code> functions were called with the same parameters, so how come they can return different things when the counters are different?</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut count_a = use_state(cx, || 0);
    let mut count_b = use_state(cx, || 0);
<span class="boring">}
</span></code></pre></pre>
<p>This is only possible because the two hooks are always called in the same order, so Dioxus knows which is which. Because the order you call hooks matters, you must follow certain rules when using hooks:</p>
<ol>
<li>Hooks may be only used in components or other hooks (we'll get to that later)</li>
<li>On every call to the component function
<ol>
<li>The same hooks must be called (except in the case of early returns, as explained later in the <a href="interactivity/../best_practices/error_handling.html">Error Handling chapter</a>)</li>
<li>In the same order</li>
</ol>
</li>
<li>Hooks name's should start with <code>use_</code> so you don't accidentally confuse them with regular functions</li>
</ol>
<p>These rules mean that there are certain things you can't do with hooks:</p>
<h3 id="no-hooks-in-conditionals"><a class="header" href="#no-hooks-in-conditionals">No Hooks in Conditionals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy &amp;&amp; you_know_it {
    let something = use_state(cx, || &quot;hands&quot;);
    println!(&quot;clap your {something}&quot;)
}

// ✅ instead, *always* call use_state
// You can put other stuff in the conditional though
let something = use_state(cx, || &quot;hands&quot;);
if you_are_happy &amp;&amp; you_know_it {
    println!(&quot;clap your {something}&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="no-hooks-in-closures"><a class="header" href="#no-hooks-in-closures">No Hooks in Closures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_state(cx, || 0);
    b.get()
};

// ✅ instead, move hook `b` outside
let b = use_state(cx, || 0);
let _a = || b.get();
<span class="boring">}
</span></code></pre></pre>
<h3 id="no-hooks-in-loops"><a class="header" href="#no-hooks-in-loops">No Hooks in Loops</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `names` is a Vec&lt;&amp;str&gt;

// ❌ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &amp;names {
    let is_selected = use_state(cx, || false);
    println!(&quot;selected: {is_selected}&quot;);
}

// ✅ Instead, use a hashmap with use_ref
let selection_map = use_ref(cx, HashMap::&lt;&amp;str, bool&gt;::new);

for name in &amp;names {
    let is_selected = selection_map.read()[name];
    println!(&quot;selected: {is_selected}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="use_ref-hook"><a class="header" href="#use_ref-hook"><code>use_ref</code> Hook</a></h2>
<p><code>use_state</code> is great for tracking simple values. However, you may notice in the <a href="https://docs.rs/dioxus/latest/dioxus/hooks/struct.UseState.html"><code>UseState</code> API</a> that the only way to modify its value is to replace it with something else (e.g., by calling <code>set</code>, or through one of the <code>+=</code>, <code>-=</code> operators). This works well when it is cheap to construct a value (such as any primitive). But what if you want to maintain more complex data in the components state?</p>
<p>For example, suppose we want to maintain a <code>Vec</code> of values. If we stored it with <code>use_state</code>, the only way to add a new value to the list would be to create a new <code>Vec</code> with the additional value, and put it in the state. This is expensive! We want to modify the existing <code>Vec</code> instead.</p>
<p>Thankfully, there is another hook for that, <code>use_ref</code>! It is similar to <code>use_state</code>, but it lets you get a mutable reference to the contained data.</p>
<p>Here's a simple example that keeps a list of events in a <code>use_ref</code>. We can acquire write access to the state with <code>.with_mut()</code>, and then just <code>.push</code> a new value to the state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    let list = use_ref(cx, Vec::new);

    cx.render(rsx!(
        p { &quot;Current list: {list.read():?}&quot; }
        button {
            onclick: move |event| {
                list.with_mut(|list| list.push(event));
            },
            &quot;Click me!&quot;
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The return values of <code>use_state</code> and <code>use_ref</code> (<code>UseState</code> and <code>UseRef</code>, respectively) are in some ways similar to <a href="https://doc.rust-lang.org/std/cell/"><code>Cell</code></a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> – they provide interior mutability. However, these Dioxus wrappers also ensure that the component gets re-rendered whenever you change the state.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-input"><a class="header" href="#user-input">User Input</a></h1>
<p>Interfaces often need to provide a way to input data: e.g. text, numbers, checkboxes, etc. In Dioxus, there are two ways you can work with user input.</p>
<h2 id="controlled-inputs"><a class="header" href="#controlled-inputs">Controlled Inputs</a></h2>
<p>With controlled inputs, you are directly in charge of the state of the input. This gives you a lot of flexibility, and makes it easy to keep things in sync. For example, this is how you would create a controlled text input:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    let name = use_state(cx, || &quot;bob&quot;.to_string());

    cx.render(rsx! {
        input {
            // we tell the component what to render
            value: &quot;{name}&quot;,
            // and what to do when the value changes
            oninput: move |evt| name.set(evt.value.clone()),
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice the flexibility – you can:</p>
<ul>
<li>Also display the same contents in another element, and they will be in sync</li>
<li>Transform the input every time it is modified (e.g. to make sure it is upper case)</li>
<li>Validate the input every time it changes</li>
<li>Have custom logic happening when the input changes (e.g. network request for autocompletion)</li>
<li>Programmatically change the value (e.g. a &quot;randomize&quot; button that fills the input with nonsense)</li>
</ul>
<h2 id="uncontrolled-inputs"><a class="header" href="#uncontrolled-inputs">Uncontrolled Inputs</a></h2>
<p>As an alternative to controlled inputs, you can simply let the platform keep track of the input values. If we don't tell a HTML input what content it should have, it will be editable anyway (this is built into the browser). This approach can be more performant, but less flexible. For example, it's harder to keep the input in sync with another element.</p>
<p>Since you don't necessarily have the current value of the uncontrolled input in state, you can access it either by listening to <code>oninput</code> events (similarly to controlled components), or, if the input is part of a form, you can access the form data in the form events (e.g. <code>oninput</code> or <code>onsubmit</code>):</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        form {
            onsubmit: move |event| {
                println!(&quot;Submitted! {event:?}&quot;)
            },
            input { name: &quot;name&quot;, },
            input { name: &quot;age&quot;, },
            input { name: &quot;date&quot;, },
            input { r#type: &quot;submit&quot;, },
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>Submitted! UiEvent { data: FormData { value: &quot;&quot;, values: {&quot;age&quot;: &quot;very old&quot;, &quot;date&quot;: &quot;1966&quot;, &quot;name&quot;: &quot;Fred&quot;} } }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharing-state"><a class="header" href="#sharing-state">Sharing State</a></h1>
<p>Often, multiple components need to access the same state. Depending on your needs, there are several ways to implement this.</p>
<h2 id="lifting-state"><a class="header" href="#lifting-state">Lifting State</a></h2>
<p>One approach to share state between components is to &quot;lift&quot; it up to the nearest common ancestor. This means putting the <code>use_state</code> hook in a parent component, and passing the needed values down as props.</p>
<p>Suppose we want to build a meme editor. We want to have an input to edit the meme caption, but also a preview of the meme with the caption. Logically, the meme and the input are 2 separate components, but they need access to the same state (the current caption).</p>
<blockquote>
<p>Of course, in this simple example, we could write everything in one component – but it is better to split everything out in smaller components to make the code more reusable, maintainable, and performant (this is even more important for larger, complex apps).</p>
</blockquote>
<p>We start with a <code>Meme</code> component, responsible for rendering a meme with a given caption:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Meme&lt;'a&gt;(cx: Scope&lt;'a&gt;, caption: &amp;'a str) -&gt; Element&lt;'a&gt; {
    let container_style = r#&quot;
        position: relative;
        width: fit-content;
    &quot;#;

    let caption_container_style = r#&quot;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 16px 8px;
    &quot;#;

    let caption_style = r&quot;
        font-size: 32px;
        margin: 0;
        color: white;
        text-align: center;
    &quot;;

    cx.render(rsx!(
        div {
            style: &quot;{container_style}&quot;,
            img {
                src: &quot;https://i.imgflip.com/2zh47r.jpg&quot;,
                height: &quot;500px&quot;,
            },
            div {
                style: &quot;{caption_container_style}&quot;,
                p {
                    style: &quot;{caption_style}&quot;,
                    &quot;{caption}&quot;
                }
            }
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that the <code>Meme</code> component is unaware where the caption is coming from – it could be stored in <code>use_state</code>, <code>use_ref</code>, or a constant. This ensures that it is very reusable – the same component can be used for a meme gallery without any changes!</p>
</blockquote>
<p>We also create a caption editor, completely decoupled from the meme. The caption editor must not store the caption itself – otherwise, how will we provide it to the <code>Meme</code> component? Instead, it should accept the current caption as a prop, as well as an event handler to delegate input events to:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn CaptionEditor&lt;'a&gt;(
    cx: Scope&lt;'a&gt;,
    caption: &amp;'a str,
    on_input: EventHandler&lt;'a, FormEvent&gt;,
) -&gt; Element&lt;'a&gt; {
    let input_style = r&quot;
        border: none;
        background: cornflowerblue;
        padding: 8px 16px;
        margin: 0;
        border-radius: 4px;
        color: white;
    &quot;;

    cx.render(rsx!(input {
        style: &quot;{input_style}&quot;,
        value: &quot;{caption}&quot;,
        oninput: move |event| on_input.call(event),
    }))
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, a third component will render the other two as children. It will be responsible for keeping the state and passing down the relevant props.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn MemeEditor(cx: Scope) -&gt; Element {
    let container_style = r&quot;
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin: 0 auto;
        width: fit-content;
    &quot;;

    let caption = use_state(cx, || &quot;me waiting for my rust code to compile&quot;.to_string());

    cx.render(rsx! {
        div {
            style: &quot;{container_style}&quot;,
            h1 { &quot;Meme Editor&quot; },
            Meme {
                caption: caption,
            },
            CaptionEditor {
                caption: caption,
                on_input: move |event: FormEvent| {caption.set(event.value.clone());},
            },
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="interactivity/./images/meme_editor_screenshot.png" alt="Meme Editor Screenshot: An old plastic skeleton sitting on a park bench. Caption: &quot;me waiting for a language feature&quot;" /></p>
<h2 id="using-context"><a class="header" href="#using-context">Using Context</a></h2>
<p>Sometimes, some state needs to be shared between multiple components far down the tree, and passing it down through props is very inconvenient.</p>
<p>Suppose now that we want to implement a dark mode toggle for our app. To achieve this, we will make every component select styling depending on whether dark mode is enabled or not.</p>
<blockquote>
<p>Note: we're choosing this approach for the sake of an example. There are better ways to implement dark mode (e.g. using CSS variables). Let's pretend CSS variables don't exist – welcome to 2013!</p>
</blockquote>
<p>Now, we could write another <code>use_state</code> in the top component, and pass <code>is_dark_mode</code> down to every component through props. But think about what will happen as the app grows in complexity – almost every component that renders any CSS is going to need to know if dark mode is enabled or not – so they'll all need the same dark mode prop. And every parent component will need to pass it down to them. Imagine how messy and verbose that would get, especially if we had components several levels deep!</p>
<p>Dioxus offers a better solution than this &quot;prop drilling&quot; – providing context. The <a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context_provider.html"><code>use_context_provider</code></a> hook is similar to <code>use_ref</code>, but it makes it available through <a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context.html"><code>use_context</code></a> for all children components.</p>
<p>First, we have to create a struct for our dark mode configuration:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DarkMode(bool);
<span class="boring">}
</span></code></pre></pre>
<p>Now, in a top-level component (like <code>App</code>), we can provide the <code>DarkMode</code> context to all children components:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use_shared_state_provider(cx, || DarkMode(false));
<span class="boring">}
</span></code></pre></pre>
<p>As a result, any child component of <code>App</code> (direct or not), can access the <code>DarkMode</code> context.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dark_mode_context = use_shared_state::&lt;DarkMode&gt;(cx);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>use_context</code> returns <code>Option&lt;UseSharedState&lt;DarkMode&gt;&gt;</code> here. If the context has been provided, the value is <code>Some(UseSharedState&lt;DarkMode&gt;)</code>, which you can call <code>.read</code> or <code>.write</code> on, similarly to <code>UseRef</code>. Otherwise, the value is <code>None</code>.</p>
</blockquote>
<p>For example, here's how we would implement the dark mode toggle, which both reads the context (to determine what color it should render) and writes to it (to toggle dark mode):</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn DarkModeToggle(cx: Scope) -&gt; Element {
    let dark_mode = use_shared_state::&lt;DarkMode&gt;(cx).unwrap();

    let style = if dark_mode.read().0 {
        &quot;color:white&quot;
    } else {
        &quot;&quot;
    };

    cx.render(rsx!(label {
        style: &quot;{style}&quot;,
        &quot;Dark Mode&quot;,
        input {
            r#type: &quot;checkbox&quot;,
            oninput: move |event| {
                let is_enabled = event.value == &quot;true&quot;;
                dark_mode.write().0 = is_enabled;
            },
        },
    }))
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-hooks"><a class="header" href="#custom-hooks">Custom Hooks</a></h1>
<p>Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.</p>
<p>When writing your hook, you can make a function that accepts <code>cx: &amp;ScopeState</code> as a parameter to accept a scope with any Props.</p>
<h2 id="composing-hooks"><a class="header" href="#composing-hooks">Composing Hooks</a></h2>
<p>To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.</p>
<p>For example, if many components need to access an <code>AppSettings</code> struct, you can create a &quot;shortcut&quot; hook:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_settings(cx: &amp;ScopeState) -&gt; &amp;UseSharedState&lt;AppSettings&gt; {
    use_shared_state::&lt;AppSettings&gt;(cx).expect(&quot;App settings not provided&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_ref hook to work with mutable state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent&lt;T: Serialize + DeserializeOwned + Default + 'static&gt;(
    cx: &amp;ScopeState,
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -&gt; T,
) -&gt; &amp;UsePersistent&lt;T&gt; {
    // Use the use_ref hook to create a mutable state for the storage entry
    let state = use_ref(cx, move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    // Note: We use use_hook here so that this hook is easier to use in closures in the rsx. Any values with the same lifetime as the ScopeState can be used in the closure without cloning.
    cx.use_hook(|| UsePersistent {
        inner: state.clone(),
    })
}

struct StorageEntry&lt;T&gt; {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent&lt;T: 'static&gt; {
    inner: UseRef&lt;StorageEntry&lt;T&gt;&gt;,
}

impl&lt;T: Serialize + DeserializeOwned + Clone + 'static&gt; UsePersistent&lt;T&gt; {
    /// Returns a reference to the value
    pub fn get(&amp;self) -&gt; T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&amp;self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &amp;value);
        inner.value = value;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="custom-hook-logic"><a class="header" href="#custom-hook-logic">Custom Hook Logic</a></h2>
<p>You can use <a href="https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.use_hook"><code>cx.use_hook</code></a> to build your own hooks. In fact, this is what all the standard hooks are built on!</p>
<p><code>use_hook</code> accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook – Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.</p>
<blockquote>
<p>Note: You can implement <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> for your hook value – it will be dropped then the component is unmounted (no longer in the UI)</p>
</blockquote>
<p>Inside the initialization closure, you will typically make calls to other <code>cx</code> methods. For example:</p>
<ul>
<li>The <code>use_state</code> hook tracks state in the hook value, and uses <a href="https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.schedule_update"><code>cx.schedule_update</code></a> to make Dioxus re-render the component whenever it changes.</li>
</ul>
<p>Here is a simplified implementation of the <code>use_state</code> hook:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

#[derive(Clone)]
struct UseState&lt;T&gt; {
    value: Rc&lt;RefCell&lt;T&gt;&gt;,
    update: Arc&lt;dyn Fn()&gt;,
}

fn my_use_state&lt;T: 'static&gt;(cx: &amp;ScopeState, init: impl FnOnce() -&gt; T) -&gt; &amp;UseState&lt;T&gt; {
    cx.use_hook(|| {
        // The update function will trigger a re-render in the component cx is attached to
        let update = cx.schedule_update();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        UseState { value, update }
    })
}

impl&lt;T: Clone&gt; UseState&lt;T&gt; {
    fn get(&amp;self) -&gt; T {
        self.value.borrow().clone()
    }

    fn set(&amp;self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The <code>use_context</code> hook calls <a href="https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.consume_context"><code>cx.consume_context</code></a> (which would be expensive to call on every render) to get some context from the scope</li>
</ul>
<p>Here is an implementation of the <code>use_context</code> and <code>use_context_provider</code> hooks:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn use_context&lt;T: 'static + Clone&gt;(cx: &amp;ScopeState) -&gt; Option&lt;&amp;T&gt; {
    cx.use_hook(|| cx.consume_context::&lt;T&gt;()).as_ref()
}

pub fn use_context_provider&lt;T: 'static + Clone&gt;(cx: &amp;ScopeState, f: impl FnOnce() -&gt; T) -&gt; &amp;T {
    cx.use_hook(|| {
        let val = f();
        // Provide the context state to the scope
        cx.provide_context(val.clone());
        val
    })
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="hook-anti-patterns"><a class="header" href="#hook-anti-patterns">Hook Anti-Patterns</a></h2>
<p>When writing a custom hook, you should avoid the following anti-patterns:</p>
<ul>
<li>!Clone Hooks: To allow hooks to be used within async blocks, the hooks must be Clone. To make a hook clone, you can wrap data in Rc or Arc and avoid lifetimes in hooks.</li>
</ul>
<p>This version of use_state may seem more efficient, but it is not cloneable:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

struct UseState&lt;'a, T&gt; {
    value: &amp;'a RefCell&lt;T&gt;,
    update: Arc&lt;dyn Fn()&gt;,
}

fn my_use_state&lt;T: 'static&gt;(cx: &amp;ScopeState, init: impl FnOnce() -&gt; T) -&gt; UseState&lt;T&gt; {
    // The update function will trigger a re-render in the component cx is attached to
    let update = cx.schedule_update();
    // Create the initial state
    let value = cx.use_hook(|| RefCell::new(init()));

    UseState { value, update }
}

impl&lt;T: Clone&gt; UseState&lt;'_, T&gt; {
    fn get(&amp;self) -&gt; T {
        self.value.borrow().clone()
    }

    fn set(&amp;self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If we try to use this hook in an async block, we will get a compile error:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn FutureComponent(cx: &amp;ScopeState) -&gt; Element {
    let my_state = my_use_state(cx, || 0);
    cx.spawn({
        to_owned![my_state];
        async move {
            my_state.set(1);
        }
    });

    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>But with the original version, we can use it in an async block:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn FutureComponent(cx: &amp;ScopeState) -&gt; Element {
    let my_state = use_state(cx, || 0);
    cx.spawn({
        to_owned![my_state];
        async move {
            my_state.set(1);
        }
    });

    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-rendering"><a class="header" href="#dynamic-rendering">Dynamic Rendering</a></h1>
<p>Sometimes you want to render different things depending on the state/props. With Dioxus, just describe what you want to see using Rust control flow – the framework will take care of making the necessary changes on the fly if the state or props change!</p>
<h2 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional Rendering</a></h2>
<p>To render different elements based on a condition, you could use an <code>if-else</code> statement:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if *is_logged_in {
    cx.render(rsx! {
        &quot;Welcome!&quot;
        button {
            onclick: move |_| on_log_out.call(()),
            &quot;Log Out&quot;,
        }
    })
} else {
    cx.render(rsx! {
        button {
            onclick: move |_| on_log_in.call(()),
            &quot;Log In&quot;,
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You could also use <code>match</code> statements, or any Rust function to conditionally render different things.</p>
</blockquote>
<h3 id="improving-the-if-else-example"><a class="header" href="#improving-the-if-else-example">Improving the <code>if-else</code> Example</a></h3>
<p>You may have noticed some repeated code in the <code>if-else</code> example above. Repeating code like this is both bad for maintainability and performance. Dioxus will skip diffing static elements like the button, but when switching between multiple <code>rsx</code> calls it cannot perform this optimization. For this example either approach is fine, but for components with large parts that are reused between conditionals, it can be more of an issue.</p>
<p>We can improve this example by splitting up the dynamic parts and inserting them where they are needed.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx! {
    // We only render the welcome message if we are logged in
    // You can use if statements in the middle of a render block to conditionally render elements
    if *is_logged_in {
        // Notice the body of this if statment is rsx code, not an expression
        &quot;Welcome!&quot;
    }
    button {
        // depending on the value of `is_logged_in`, we will call a different event handler
        onclick: move |_| if *is_logged_in {
            on_log_in.call(())
        }
        else{
            on_log_out.call(())
        },
        if *is_logged_in {
            // if we are logged in, the button should say &quot;Log Out&quot;
            &quot;Log Out&quot;
        } else {
            // if we are not logged in, the button should say &quot;Log In&quot;
            &quot;Log In&quot;
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="inspecting-element-props"><a class="header" href="#inspecting-element-props">Inspecting <code>Element</code> props</a></h3>
<p>Since <code>Element</code> is a <code>Option&lt;VNode&gt;</code>, components accepting <code>Element</code> as a prop can inspect its contents, and render different things based on that. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    match cx.props.children {
        Some(VNode { dynamic_nodes, .. }) =&gt; {
            todo!(&quot;render some stuff&quot;)
        }
        _ =&gt; {
            todo!(&quot;render some other stuff&quot;)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can't mutate the <code>Element</code>, but if you need a modified version of it, you can construct a new one based on its attributes/children/etc.</p>
<h2 id="rendering-nothing"><a class="header" href="#rendering-nothing">Rendering Nothing</a></h2>
<p>To render nothing, you can return <code>None</code> from a component. This is useful if you want to conditionally hide something:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if *is_logged_in {
    return None;
}

cx.render(rsx! {
    a {
        &quot;You must be logged in to comment&quot;
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>This works because the <code>Element</code> type is just an alias for <code>Option&lt;VNode&gt;</code></p>
<blockquote>
<p>Again, you may use a different method to conditionally return <code>None</code>. For example the boolean's <a href="https://doc.rust-lang.org/std/primitive.bool.html#method.then"><code>then()</code></a> function could be used.</p>
</blockquote>
<h2 id="rendering-lists"><a class="header" href="#rendering-lists">Rendering Lists</a></h2>
<p>Often, you'll want to render a collection of components. For example, you might want to render a list of all comments on a post.</p>
<p>For this, Dioxus accepts iterators that produce <code>Element</code>s. So we need to:</p>
<ul>
<li>Get an iterator over all of our items (e.g., if you have a <code>Vec</code> of comments, iterate over it with <code>iter()</code>)</li>
<li><code>.map</code> the iterator to convert each item into a <code>LazyNode</code> using <code>rsx!(...)</code>
<ul>
<li>Add a unique <code>key</code> attribute to each iterator item</li>
</ul>
</li>
<li>Include this iterator in the final RSX (or use it inline)</li>
</ul>
<p>Example: suppose you have a list of comments you want to render. Then, you can render them like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::&lt;Comment&gt;::new);

let comments_lock = comments.read();
let comments_rendered = comments_lock.iter().map(|comment| {
    rsx!(CommentComponent {
        key: &quot;{comment.id}&quot;,
        comment: comment.clone(),
    })
});

cx.render(rsx!(
    form {
        onsubmit: move |_| {
            comments.write().push(Comment {
                content: comment_field.get().clone(),
                id: *next_id.get(),
            });
            next_id += 1;

            comment_field.set(String::new());
        },
        input {
            value: &quot;{comment_field}&quot;,
            oninput: |event| comment_field.set(event.value.clone()),
        }
        input {
            r#type: &quot;submit&quot;,
        }
    },
    comments_rendered,
))
<span class="boring">}
</span></code></pre></pre>
<h3 id="inline-for-loops"><a class="header" href="#inline-for-loops">Inline for loops</a></h3>
<p>Because of how common it is to render a list of items, Dioxus provides a shorthand for this. Instead of using <code>.iter, </code>.map<code>, and </code>rsx<code>, you can use a </code>for` loop with a body of rsx code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::&lt;Comment&gt;::new);

cx.render(rsx!(
    form {
        onsubmit: move |_| {
            comments.write().push(Comment {
                content: comment_field.get().clone(),
                id: *next_id.get(),
            });
            next_id += 1;

            comment_field.set(String::new());
        },
        input {
            value: &quot;{comment_field}&quot;,
            oninput: |event| comment_field.set(event.value.clone()),
        }
        input {
            r#type: &quot;submit&quot;,
        }
    },
    for comment in &amp;*comments.read() {
        // Notice the body of this for loop is rsx code, not an expression
        CommentComponent {
            key: &quot;{comment.id}&quot;,
            comment: comment.clone(),
        }
    }
))
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-key-attribute"><a class="header" href="#the-key-attribute">The <code>key</code> Attribute</a></h3>
<p>Every time you re-render your list, Dioxus needs to keep track of which items go where to determine what updates need to be made to the UI.</p>
<p>For example, suppose the <code>CommentComponent</code> had some state – e.g. a field where the user typed in a reply. If the order of comments suddenly changes, Dioxus needs to correctly associate that state with the same comment – otherwise, the user will end up replying to a different comment!</p>
<p>To help Dioxus keep track of list items, we need to associate each item with a unique key. In the example above, we dynamically generated the unique key. In real applications, it's more likely that the key will come from e.g. a database ID. It doesn't matter where you get the key from, as long as it meets the requirements:</p>
<ul>
<li>Keys must be unique in a list</li>
<li>The same item should always get associated with the same key</li>
<li>Keys should be relatively small (i.e. converting the entire Comment structure to a String would be a pretty bad key) so they can be compared efficiently</li>
</ul>
<p>You might be tempted to use an item's index in the list as its key. That’s what Dioxus will use if you don’t specify a key at all. This is only acceptable if you can guarantee that the list is constant – i.e., no re-ordering, additions, or deletions.</p>
<blockquote>
<p>Note that if you pass the key to a component you've made, it won't receive the key as a prop. It’s only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">Router</a></h1>
<p>In many of your apps, you'll want to have different &quot;scenes&quot;. For a webpage, these scenes might be the different webpages with their own content. For a desktop app, these scenes might be different views in your app.</p>
<p>To unify these platforms, Dioxus provides a first-party solution for scene management called Dioxus Router.</p>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have several different scenes:</p>
<ul>
<li>Homepage</li>
<li>Blog</li>
</ul>
<p>Each of these scenes is independent – we don't want to render both the homepage and blog at the same time.</p>
<p>The Dioxus router makes it easy to create these scenes. To make sure we're using the router, add the <code>dioxus-router</code> package to your <code>Cargo.toml</code>.</p>
<pre><code class="language-shell">cargo add dioxus-router
</code></pre>
<h2 id="using-the-router"><a class="header" href="#using-the-router">Using the router</a></h2>
<p>Unlike other routers in the Rust ecosystem, our router is built declaratively. This makes it possible to compose our app layout simply by arranging components.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    // All of our routes will be rendered inside this Router component
    Router {
        // if the current location is &quot;/home&quot;, render the Home component
        Route { to: &quot;/home&quot;, Home {} }
        // if the current location is &quot;/blog&quot;, render the Blog component
        Route { to: &quot;/blog&quot;, Blog {} }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.</p>
<p>We can fix this one of two ways:</p>
<ul>
<li>A fallback 404 page</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Router {
        Route { to: &quot;/home&quot;, Home {} }
        Route { to: &quot;/blog&quot;, Blog {} }
        //  if the current location doesn't match any of the above routes, render the NotFound component
        Route { to: &quot;&quot;, NotFound {} }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Redirect 404 to home</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Router {
        Route { to: &quot;/home&quot;, Home {} }
        Route { to: &quot;/blog&quot;, Blog {} }
        //  if the current location doesn't match any of the above routes, redirect to &quot;/home&quot;
        Redirect { from: &quot;&quot;, to: &quot;/home&quot; }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<p>For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap <code>&lt;a&gt;</code> elements that, when clicked, navigate the app to the given location.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Link {
        to: &quot;/home&quot;,
        &quot;Go home!&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="more-reading"><a class="header" href="#more-reading">More reading</a></h2>
<p>This page is just a very brief overview of the router. For more information, check out <a href="https://dioxuslabs.com/docs/0.3/router/">the router book</a> or some of <a href="https://github.com/DioxusLabs/dioxus/blob/master/examples/router.rs">the router examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-async"><a class="header" href="#working-with-async">Working with Async</a></h1>
<p>Often, apps need to interact with file systems, network interfaces, hardware, or timers. This chapter provides an overview of using async code in Dioxus.</p>
<h2 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h2>
<p>By default, Dioxus-Desktop ships with the <code>Tokio</code> runtime and automatically sets everything up for you. This is currently not configurable, though it would be easy to write an integration for Dioxus desktop that uses a different asynchronous runtime.</p>
<p>Dioxus is not currently thread-safe, so any async code you write does <em>not</em> need to be <code>Send/Sync</code>. That means that you can use non-thread-safe structures like <code>Cell</code>, <code>Rc</code>, and <code>RefCell</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usefuture"><a class="header" href="#usefuture">UseFuture</a></h1>
<p><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html"><code>use_future</code></a> lets you run an async closure, and provides you with its result.</p>
<p>For example, we can make an API request (using <a href="https://docs.rs/reqwest/latest/reqwest/index.html">reqwest</a>) inside <code>use_future</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let future = use_future(cx, (), |_| async move {
    reqwest::get(&quot;https://dog.ceo/api/breeds/image/random&quot;)
        .await
        .unwrap()
        .json::&lt;ApiResponse&gt;()
        .await
});
<span class="boring">}
</span></code></pre></pre>
<p>The code inside <code>use_future</code> will be submitted to the Dioxus scheduler once the component has rendered.</p>
<p>We can use <code>.value()</code> to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be <code>None</code>.  However, once the future is finished, the component will be re-rendered and the value will now be <code>Some(...)</code>, containing the return value of the closure.</p>
<p>We can then render that result:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(match future.value() {
    Some(Ok(response)) =&gt; rsx! {
        button {
            onclick: move |_| future.restart(),
            &quot;Click to fetch another doggo&quot;
        }
        div {
            img {
                max_width: &quot;500px&quot;,
                max_height: &quot;500px&quot;,
                src: &quot;{response.image_url}&quot;,
            }
        }
    },
    Some(Err(_)) =&gt; rsx! { div { &quot;Loading dogs failed&quot; } },
    None =&gt; rsx! { div { &quot;Loading dogs...&quot; } },
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="restarting-the-future"><a class="header" href="#restarting-the-future">Restarting the Future</a></h2>
<p>The <code>UseFuture</code> handle provides a <code>restart</code> method. It can be used to execute the future again, producing a new value.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Often, you will need to run the future again every time some value (e.g. a prop) changes. Rather than calling <code>restart</code> manually, you can provide a tuple of &quot;dependencies&quot; to the hook. It will automatically re-run the future when any of those dependencies change. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let future = use_future(cx, (breed,), |(breed,)| async move {
    reqwest::get(format!(&quot;https://dog.ceo/api/breed/{breed}/images/random&quot;))
        .await
        .unwrap()
        .json::&lt;ApiResponse&gt;()
        .await
});
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h1>
<p>Another tool in your async toolbox are coroutines. Coroutines are futures that can be manually stopped, started, paused, and resumed.</p>
<p>Like regular futures, code in a coroutine will run until the next <code>await</code> point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.</p>
<h2 id="use_coroutine"><a class="header" href="#use_coroutine"><code>use_coroutine</code></a></h2>
<p>The <code>use_coroutine</code> hook allows you to create a coroutine. Most coroutines we write will be polling loops using async/await.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let ws: &amp;UseCoroutine&lt;()&gt; = use_coroutine(cx, |rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>For many services, a simple async loop will handle the majority of use cases.</p>
<p>However, if we want to temporarily disable the coroutine, we can &quot;pause&quot; it using the <code>pause</code> method, and &quot;resume&quot; it using the <code>resume</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sync: &amp;UseCoroutine&lt;()&gt; = use_coroutine(cx, |rx| async move {
    // code for syncing
});

if sync.is_running() {
    cx.render(rsx!{
        button {
            onclick: move |_| sync.pause(),
            &quot;Disable syncing&quot;
        }
    })
} else {
    cx.render(rsx!{
        button {
            onclick: move |_| sync.resume(),
            &quot;Enable syncing&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This pattern is where coroutines are extremely useful – instead of writing all the complicated logic for pausing our async tasks like we would with JavaScript promises, the Rust model allows us to just not poll our future.</p>
<h2 id="yielding-values"><a class="header" href="#yielding-values">Yielding Values</a></h2>
<p>To yield values from a coroutine, simply bring in a <code>UseState</code> handle and set the value whenever your coroutine completes its work.</p>
<p>The future must be <code>'static</code> – so any values captured by the task cannot carry any references to <code>cx</code>, such as a <code>UseState</code>.</p>
<p>You can use <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned">to_owned</a> to create a clone of the hook handle which can be moved into the async closure.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sync_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver&lt;SyncAction&gt;| {
    let sync_status = sync_status.to_owned();
    async move {
        loop {
            delay_ms(1000).await;
            sync_status.set(Status::Working);
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>To make this a bit less verbose, Dioxus exports the <code>to_owned!</code> macro which will create a binding as shown above, which can be quite helpful when dealing with many values.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sync_status = use_state(cx, || Status::Launching);
let load_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver&lt;SyncAction&gt;| {
    to_owned![sync_status, load_status];
    async move {
        // ...
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="sending-values"><a class="header" href="#sending-values">Sending Values</a></h2>
<p>You might've noticed the <code>use_coroutine</code> closure takes an argument called <code>rx</code>. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.</p>
<p>With Coroutines, we can centralize our async logic. The <code>rx</code> parameter is an Channel that allows code external to the coroutine to send data <em>into</em> the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call &quot;send&quot; on the handle.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures_util::stream::StreamExt;

enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32)
}

let profile = use_coroutine(cx, |mut rx: UnboundedReciver&lt;ProfileUpdate&gt;| async move {
    let mut server = connect_to_server().await;

    while let Ok(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) =&gt; server.update_username(name).await,
            ProfileUpdate::SetAge(age) =&gt; server.update_age(age).await,
        }
    }
});


cx.render(rsx!{
    button {
        onclick: move |_| profile.send(ProfileUpdate::SetUsername(&quot;Bob&quot;.to_string())),
        &quot;Update username&quot;
    }
})
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: In order to use/run the <code>rx.next().await</code> statement you will need to extend the [<code>Stream</code>] trait (used by [<code>UnboundedReceiver</code>]) by adding 'futures_util' as a dependency to your project and adding the <code>use futures_util::stream::StreamExt;</code>.</p>
</blockquote>
<p>For sufficiently complex apps, we could build a bunch of different useful &quot;services&quot; that loop on channels to update the app.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let profile = use_coroutine(cx, profile_service);
let editor = use_coroutine(cx, editor_service);
let sync = use_coroutine(cx, sync_service);

async fn profile_service(rx: UnboundedReceiver&lt;ProfileCommand&gt;) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver&lt;SyncCommand&gt;) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver&lt;EditorCommand&gt;) {
    // do stuff
}
<span class="boring">}
</span></code></pre></pre>
<p>We can combine coroutines with <a href="https://docs.rs/fermi/latest/fermi/index.html">Fermi</a> to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state <em>within</em> a task and then simply update the &quot;view&quot; values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your <em>actual</em> state does not need to be tied up in a system like Fermi or Redux – the only Atoms that need to exist are those that are used to drive the display/UI.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static USERNAME: Atom&lt;String&gt; = |_| &quot;default&quot;.to_string();

fn app(cx: Scope) -&gt; Element {
    let atoms = use_atom_root(cx);

    use_coroutine(cx, |rx| sync_service(rx, atoms.clone()));

    cx.render(rsx!{
        Banner {}
    })
}

fn Banner(cx: Scope) -&gt; Element {
    let username = use_read(cx, USERNAME);

    cx.render(rsx!{
        h1 { &quot;Welcome back, {username}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures_util::stream::StreamExt;

enum SyncAction {
    SetUsername(String),
}

async fn sync_service(mut rx: UnboundedReceiver&lt;SyncAction&gt;, atoms: AtomRoot) {
    let username = atoms.write(USERNAME);
    let errors = atoms.write(ERRORS);

    while let Ok(msg) = rx.next().await {
        match msg {
            SyncAction::SetUsername(name) =&gt; {
                if set_name_on_server(&amp;name).await.is_ok() {
                    username.set(name);
                } else {
                    errors.make_mut().push(&quot;SetUsernameFailed&quot;);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="automatic-injection-into-the-context-api"><a class="header" href="#automatic-injection-into-the-context-api">Automatic injection into the Context API</a></h2>
<p>Coroutine handles are automatically injected through the context API. You can use the <code>use_coroutine_handle</code> hook with the message type as a generic to fetch a handle.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Child(cx: Scope) -&gt; Element {
    let sync_task = use_coroutine_handle::&lt;SyncAction&gt;(cx);

    sync_task.send(SyncAction::SetUsername);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-futures"><a class="header" href="#spawning-futures">Spawning Futures</a></h1>
<p>The <code>use_future</code> and <code>use_coroutine</code> hooks are useful if you want to unconditionally spawn the future. Sometimes, though, you'll want to only spawn a future in response to an event, such as a mouse click. For example, suppose you need to send a request when the user clicks a &quot;log in&quot; button. For this, you can use <code>cx.spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let logged_in = use_state(cx, || false);

    let log_in = move |_| {
        cx.spawn({
            let logged_in = logged_in.to_owned();

            async move {
                let resp = reqwest::Client::new()
                    .post(&quot;http://example.com/login&quot;)
                    .send()
                    .await;

                match resp {
                    Ok(_data) =&gt; {
                        println!(&quot;Login successful!&quot;);
                        logged_in.set(true);
                    }
                    Err(_err) =&gt; {
                        println!(
                            &quot;Login failed - you need a login server running on localhost:8080.&quot;
                        )
                    }
                }
            }
        });
    };

    cx.render(rsx! {
        button {
            onclick: log_in,
            &quot;Login&quot;,
        }
    })
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: <code>spawn</code> will always spawn a <em>new</em> future. You most likely don't want to call it on every render.</p>
</blockquote>
<p>Calling <code>spawn</code> will give you a <code>JoinHandle</code> which lets you cancel or pause the future.</p>
<h2 id="spawning-tokio-tasks"><a class="header" href="#spawning-tokio-tasks">Spawning Tokio Tasks</a></h2>
<p>Sometimes, you might want to spawn a background task that needs multiple threads or talk to hardware that might block your app code. In these cases, we can directly spawn a Tokio task from our future. For Dioxus-Desktop, your task will be spawned onto Tokio's Multithreaded runtime:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        cx.spawn(async {
            let _ = tokio::spawn(async {}).await;

            let _ = tokio::task::spawn_local(async {
                // some !Send work
            })
            .await;
        });
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<h2 id="reusable-components"><a class="header" href="#reusable-components">Reusable Components</a></h2>
<p>As much as possible, break your code down into small, reusable components and hooks, instead of implementing large chunks of the UI in a single component. This will help you keep the code maintainable – it is much easier to e.g. add, remove or re-order parts of the UI if it is organized in components.</p>
<p>Organize your components in modules to keep the codebase easy to navigate!</p>
<h2 id="minimize-state-dependencies"><a class="header" href="#minimize-state-dependencies">Minimize State Dependencies</a></h2>
<p>While it is possible to share state between components, this should only be done when necessary. Any component that is associated with a particular state object needs to be re-rendered when that state changes. For this reason:</p>
<ul>
<li>Keep state local to a component if possible</li>
<li>When sharing state through props, only pass down the specific data necessary</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them</p>
<p>However, we haven't talked about error handling at all in this guide! In this chapter, we'll cover some strategies in handling errors to ensure your app never crashes.</p>
<h2 id="the-simplest--returning-none"><a class="header" href="#the-simplest--returning-none">The simplest – returning None</a></h2>
<p>Astute observers might have noticed that <code>Element</code> is actually a type alias for <code>Option&lt;VNode&gt;</code>. You don't need to know what a <code>VNode</code> is, but it's important to recognize that we could actually return nothing at all:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>This lets us add in some syntactic sugar for operations we think <em>shouldn't</em> fail, but we're still not confident enough to &quot;unwrap&quot; on.</p>
<blockquote>
<p>The nature of <code>Option&lt;VNode&gt;</code> might change in the future as the <code>try</code> trait gets upgraded.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    // immediately return &quot;None&quot;
    let name = cx.use_hook(|_| Some(&quot;hi&quot;))?;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="early-return-on-result"><a class="header" href="#early-return-on-result">Early return on result</a></h2>
<p>Because Rust can't accept both Options and Results with the existing try infrastructure, you'll need to manually handle Results. This can be done by converting them into Options or by explicitly handling them.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    // Convert Result to Option
    let name = cx.use_hook(|_| &quot;1.234&quot;).parse().ok()?;


    // Early return
    let count = cx.use_hook(|_| &quot;1.234&quot;);
    let val = match count.parse() {
        Ok(val) =&gt; val
        Err(err) =&gt; return cx.render(rsx!{ &quot;Parsing failed&quot; })
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that while hooks in Dioxus do not like being called in conditionals or loops, they <em>are</em> okay with early returns. Returning an error state early is a completely valid way of handling errors.</p>
<h2 id="match-results"><a class="header" href="#match-results">Match results</a></h2>
<p>The next &quot;best&quot; way of handling errors in Dioxus is to match on the error locally. This is the most robust way of handling errors, though it doesn't scale to architectures beyond a single component.</p>
<p>To do this, we simply have an error state built into our component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = use_state(cx, || None);
<span class="boring">}
</span></code></pre></pre>
<p>Whenever we perform an action that generates an error, we'll set that error state. We can then match on the error in a number of ways (early return, return Element, etc).</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Commandline(cx: Scope) -&gt; Element {
    let error = use_state(cx, || None);

    cx.render(match *error {
        Some(error) =&gt; rsx!(
            h1 { &quot;An error occured&quot; }
        )
        None =&gt; rsx!(
            input {
                oninput: move |_| error.set(Some(&quot;bad thing happened!&quot;)),
            }
        )
    })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="passing-error-states-through-components"><a class="header" href="#passing-error-states-through-components">Passing error states through components</a></h2>
<p>If you're dealing with a handful of components with minimal nesting, you can just pass the error handle into child components.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Commandline(cx: Scope) -&gt; Element {
    let error = use_state(cx, || None);

    if let Some(error) = **error {
        return cx.render(rsx!{ &quot;An error occured&quot; });
    }

    cx.render(rsx!{
        Child { error: error.clone() }
        Child { error: error.clone() }
        Child { error: error.clone() }
        Child { error: error.clone() }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Much like before, our child components can manually set the error during their own actions. The advantage to this pattern is that we can easily isolate error states to a few components at a time, making our app more predictable and robust.</p>
<h2 id="going-global"><a class="header" href="#going-global">Going global</a></h2>
<p>A strategy for handling cascaded errors in larger apps is through signaling an error using global state. This particular pattern involves creating an &quot;error&quot; context, and then setting it wherever relevant. This particular method is not as &quot;sophisticated&quot; as React's error boundary, but it is more fitting for Rust.</p>
<p>To get started, consider using a built-in hook like <code>use_context</code> and <code>use_context_provider</code> or Fermi. Of course, it's pretty easy to roll your own hook too.</p>
<p>At the &quot;top&quot; of our architecture, we're going to want to explicitly declare a value that could be an error.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum InputError {
    None,
    TooLong,
    TooShort,
}

static INPUT_ERROR: Atom&lt;InputError&gt; = |_| InputError::None;
<span class="boring">}
</span></code></pre></pre>
<p>Then, in our top level component, we want to explicitly handle the possible error state for this part of the tree.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn TopLevel(cx: Scope) -&gt; Element {
    let error = use_read(cx, INPUT_ERROR);

    match error {
        TooLong =&gt; return cx.render(rsx!{ &quot;FAILED: Too long!&quot; }),
        TooShort =&gt; return cx.render(rsx!{ &quot;FAILED: Too Short!&quot; }),
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, whenever a downstream component has an error in its actions, it can simply just set its own error state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Commandline(cx: Scope) -&gt; Element {
    let set_error = use_set(cx, INPUT_ERROR);

    cx.render(rsx!{
        input {
            oninput: move |evt| {
                if evt.value.len() &gt; 20 {
                    set_error(InputError::TooLong);
                }
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This approach to error handling is best in apps that have &quot;well defined&quot; error states. Consider using a crate like <code>thiserror</code> or <code>anyhow</code> to simplify the generation of the error types.</p>
<p>This pattern is widely popular in many contexts and is particularly helpful whenever your code generates a non-recoverable error. You can gracefully capture these &quot;global&quot; error states without panicking or mucking up state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="antipatterns"><a class="header" href="#antipatterns">Antipatterns</a></h1>
<p>This example shows what not to do and provides a reason why a given pattern is considered an &quot;AntiPattern&quot;. Most anti-patterns are considered wrong for performance or code re-usability reasons.</p>
<h2 id="unnecessarily-nested-fragments"><a class="header" href="#unnecessarily-nested-fragments">Unnecessarily Nested Fragments</a></h2>
<p>Fragments don't mount a physical element to the DOM immediately, so Dioxus must recurse into its children to find a physical DOM node. This process is called &quot;normalization&quot;. This means that deeply nested fragments make Dioxus perform unnecessary work. Prefer one or two levels of fragments / nested components until presenting a true DOM element.</p>
<p>Only Component and Fragment nodes are susceptible to this issue. Dioxus mitigates this with components by providing an API for registering shared state without the Context Provider pattern.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // ❌ Don't unnecessarily nest fragments
    let _ = cx.render(rsx!(
        Fragment {
            Fragment {
                Fragment {
                    Fragment {
                        Fragment {
                            div { &quot;Finally have a real node!&quot; }
                        }
                    }
                }
            }
        }
    ));

    // ✅ Render shallow structures
    cx.render(rsx!(
        div { &quot;Finally have a real node!&quot; }
    ))
<span class="boring">}
</span></code></pre></pre>
<h2 id="incorrect-iterator-keys"><a class="header" href="#incorrect-iterator-keys">Incorrect Iterator Keys</a></h2>
<p>As described in the <a href="best_practices/../interactivity/dynamic_rendering.html#the-key-attribute">dynamic rendering chapter</a>, list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let data: &amp;HashMap&lt;_, _&gt; = &amp;cx.props.data;

    // ❌ No keys
    cx.render(rsx! {
        ul {
            data.values().map(|value| rsx!(
                li { &quot;List item: {value}&quot; }
            ))
        }
    });

    // ❌ Using index as keys
    cx.render(rsx! {
        ul {
            cx.props.data.values().enumerate().map(|(index, value)| rsx!(
                li { key: &quot;{index}&quot;, &quot;List item: {value}&quot; }
            ))
        }
    });

    // ✅ Using unique IDs as keys:
    cx.render(rsx! {
        ul {
            cx.props.data.iter().map(|(key, value)| rsx!(
                li { key: &quot;{key}&quot;, &quot;List item: {value}&quot; }
            ))
        }
    })
<span class="boring">}
</span></code></pre></pre>
<h2 id="avoid-interior-mutability-in-props"><a class="header" href="#avoid-interior-mutability-in-props">Avoid Interior Mutability in Props</a></h2>
<p>While it is technically acceptable to have a <code>Mutex</code> or a <code>RwLock</code> in the props, they will be difficult to use.</p>
<p>Suppose you have a struct <code>User</code> containing the field <code>username: String</code>. If you pass a <code>Mutex&lt;User&gt;</code> prop to a <code>UserComponent</code> component, that component may wish to pass the username as a <code>&amp;str</code> prop to a child component. However, it cannot pass that borrowed field down, since it only would live as long as the <code>Mutex</code>'s lock, which belongs to the <code>UserComponent</code> function. Therefore, the component will be forced to clone the <code>username</code> field.</p>
<h2 id="avoid-updating-state-during-render"><a class="header" href="#avoid-updating-state-during-render">Avoid Updating State During Render</a></h2>
<p>Every time you update the state, Dioxus needs to re-render the component – this is inefficient! Consider refactoring your code to avoid this.</p>
<p>Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing"><a class="header" href="#publishing">Publishing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-1"><a class="header" href="#publishing-1">Publishing</a></h1>
<p>Congrats! You've made your first Dioxus app that actually does some pretty cool stuff. This app uses your operating system's WebView library, so it's portable to be distributed for other platforms.</p>
<p>In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.</p>
<h2 id="install-cargo-bundle"><a class="header" href="#install-cargo-bundle">Install <code>cargo-bundle</code></a></h2>
<p>The first thing we'll do is install <a href="https://github.com/burtonageo/cargo-bundle"><code>cargo-bundle</code></a>. This extension to cargo will make it very easy to package our app for the various platforms.</p>
<p>According to the <code>cargo-bundle</code> github page, </p>
<p><em>&quot;cargo-bundle is a tool used to generate installers or app bundles for GUI  executables built with cargo. It can create .app bundles for Mac OS X and iOS, .deb packages for Linux, and .msi installers for Windows (note however that iOS and Windows support is still experimental). Support for creating .rpm packages (for Linux) and .apk packages (for Android) is still pending.&quot;</em></p>
<p>To install, simply run</p>
<p><code>cargo install cargo-bundle</code></p>
<h2 id="setting-up-your-project"><a class="header" href="#setting-up-your-project">Setting up your project</a></h2>
<p>To get a project setup for bundling, we need to add some flags to our <code>Cargo.toml</code> file. </p>
<pre><code class="language-toml">[package]
name = &quot;example&quot;
# ...other fields...

[package.metadata.bundle]
name = &quot;DogSearch&quot;
identifier = &quot;com.dogs.dogsearch&quot;
version = &quot;1.0.0&quot;
copyright = &quot;Copyright (c) Jane Doe 2016. All rights reserved.&quot;
category = &quot;Developer Tool&quot;
short_description = &quot;Easily search for Dog photos&quot;
long_description = &quot;&quot;&quot;
This app makes it quick and easy to browse photos of dogs from over 200 bree
&quot;&quot;&quot;
</code></pre>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>Following cargo-bundle's instructions, we simply <code>cargo-bundle --release</code> to produce a final app with all the optimizations and assets builtin.</p>
<p>Once you've ran <code>cargo-bundle --release</code>, your app should be accessible in</p>
<p><code>target/release/bundle/&lt;platform&gt;/</code>.</p>
<p>For example, a macOS app would look like this:</p>
<p><img src="publishing/../images/publish.png" alt="Published App" /></p>
<p>Nice! And it's only 4.8 Mb – extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.</p>
<blockquote>
<p>Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform – or web browser (Firefox, Chrome, Safari) before publishing.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="publishing-with-github-pages"><a class="header" href="#publishing-with-github-pages">Publishing with Github Pages</a></h2>
<p>To build our app and publish it to Github:</p>
<ul>
<li>Make sure GitHub Pages is set up for your repo</li>
<li>Build your app with <code>trunk build --release</code> (include <code>--public-url &lt;repo-name&gt;</code> to update asset prefixes if using a project site)</li>
<li>Move your generated HTML/CSS/JS/Wasm from <code>dist</code> into the folder configured for Github Pages</li>
<li>Add and commit with git</li>
<li>Push to GitHub</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fullstack-development"><a class="header" href="#fullstack-development">Fullstack development</a></h1>
<p>So far you have learned about three different approaches to target the web with Dioxus:</p>
<ul>
<li><a href="fullstack/../getting_started/web.html">Client-side rendering with dioxus-web</a></li>
<li><a href="fullstack/../getting_started/liveview.html">Server-side rendering with dioxus-liveview</a></li>
<li><a href="fullstack/../getting_started/ssr.html">Server-side static HTML generation with dioxus-ssr</a></li>
</ul>
<h2 id="summary-of-existing-approaches"><a class="header" href="#summary-of-existing-approaches">Summary of Existing Approaches</a></h2>
<p>Each approach has its tradeoffs:</p>
<h3 id="client-side-rendering"><a class="header" href="#client-side-rendering">Client-side rendering</a></h3>
<ul>
<li>
<p>With Client side rendering, you send the entire content of your application to the client, and then the client generates all of the HTML of the page dynamically.</p>
</li>
<li>
<p>This means that the page will be blank until the JavaScript bundle has loaded and the application has initialized. This can result in <strong>slower first render times and makes the page less SEO-friendly</strong>.</p>
</li>
</ul>
<blockquote>
<p>SEO stands for Search Engine Optimization. It refers to the practice of making your website more likely to appear in search engine results. Search engines like Google and Bing use web crawlers to index the content of websites. Most of these crawlers are not able to run JavaScript, so they will not be able to index the content of your page if it is rendered client-side.</p>
</blockquote>
<ul>
<li>Client-side rendered applications need to use <strong>weakly typed requests to communicate with the server</strong></li>
</ul>
<blockquote>
<p>Client-side rendering is a good starting point for most applications. It is well supported and makes it easy to communicate with the client/browser APIs</p>
</blockquote>
<h3 id="liveview-1"><a class="header" href="#liveview-1">Liveview</a></h3>
<ul>
<li>
<p>Liveview rendering communicates with the server over a WebSocket connection. It essentially moves all of the work that Client-side rendering does to the server.</p>
</li>
<li>
<p>This makes it <strong>easy to communicate with the server, but more difficult to communicate with the client/browser APIS</strong>.</p>
</li>
<li>
<p>Each interaction also requires a message to be sent to the server and back which can cause <strong>issues with latency</strong>.</p>
</li>
<li>
<p>Because Liveview uses a websocket to render, the page will be blank until the WebSocket connection has been established and the first renderer has been sent form the websocket. Just like with client side rendering, this can make the page <strong>less SEO-friendly</strong>.</p>
</li>
<li>
<p>Because the page is rendered on the server and the page is sent to the client piece by piece, you never need to send the entire application to the client. The initial load time can be faster than client-side rendering with large applications because Liveview only needs to send a constant small websocket script regardless of the size of the application.</p>
</li>
</ul>
<blockquote>
<p>Liveview is a good fit for applications that already need to communicate with the server frequently (like real time collaborative apps), but don't need to communicate with as many client/browser APIs</p>
</blockquote>
<h3 id="server-side-rendering-1"><a class="header" href="#server-side-rendering-1">Server-side rendering</a></h3>
<ul>
<li>Server-side rendering generates all of the HTML of the page on the server before the page is sent to the client. This means that the page will be fully rendered when it is sent to the client. This results in a faster first render time and makes the page more SEO-friendly. However, it <strong>only works for static pages</strong>.</li>
</ul>
<blockquote>
<p>Server-side rendering is not a good fit for purely static sites like a blog</p>
</blockquote>
<h2 id="a-new-approach"><a class="header" href="#a-new-approach">A New Approach</a></h2>
<p>Each of these approaches has its tradeoffs. What if we could combine the best parts of each approach?</p>
<ul>
<li><strong>Fast initial render</strong> time like SSR</li>
<li><strong>Works well with SEO</strong> like SSR</li>
<li><strong>Type safe easy communication with the server</strong> like Liveview</li>
<li><strong>Access to the client/browser APIs</strong> like Client-side rendering</li>
<li><strong>Fast interactivity</strong> like Client-side rendering</li>
</ul>
<p>We can achieve this by rendering the initial page on the server (SSR) and then taking over rendering on the client (Client-side rendering). Taking over rendering on the client is called <strong>hydration</strong>.</p>
<p>Finally, we can use <a href="fullstack/server_functions.html">server functions</a> to communicate with the server in a type-safe way.</p>
<p>This approach uses both the dioxus-web and dioxus-ssr crates. To integrate those two packages and <code>axum</code>, <code>warp</code>, or <code>salvo</code>, Dioxus provides the <code>dioxus-fullstack</code> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This guide assumes you read the <a href="fullstack/web.html">Web</a> guide and installed the <a href="https://github.com/DioxusLabs/cli">Dioxus-cli</a></p>
</blockquote>
<h1 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h1>
<h2 id="setup-4"><a class="header" href="#setup-4">Setup</a></h2>
<p>For this guide, we're going to show how to use Dioxus with <a href="https://docs.rs/axum/latest/axum/">Axum</a>, but <code>dioxus-fullstack</code> also integrates with the <a href="https://docs.rs/warp/latest/warp/">Warp</a> and <a href="https://docs.rs/salvo/latest/salvo/">Salvo</a> web frameworks.</p>
<p>Make sure you have Rust and Cargo installed, and then create a new project:</p>
<pre><code class="language-shell">cargo new --bin demo
cd demo
</code></pre>
<p>Add <code>dioxus</code> and <code>dioxus-fullstack</code> as dependencies:</p>
<pre><code class="language-shell">cargo add dioxus
cargo add dioxus-fullstack --features axum, ssr
</code></pre>
<p>Next, add all the Axum dependencies. This will be different if you're using a different Web Framework</p>
<pre><code class="language-shell">cargo add tokio --features full
cargo add axum
</code></pre>
<p>Your dependencies should look roughly like this:</p>
<pre><code class="language-toml">[dependencies]
axum = &quot;*&quot;
dioxus = { version = &quot;*&quot; }
dioxus-fullstack = { version = &quot;*&quot;, features = [&quot;axum&quot;, &quot;ssr&quot;] }
tokio = { version = &quot;*&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>Now, set up your Axum app to serve the Dioxus app.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case, unused)]
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    #[cfg(feature = &quot;ssr&quot;)]
    {
        use dioxus_fullstack::prelude::*;

        let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8080));
        axum::Server::bind(&amp;addr)
            .serve(
                axum::Router::new()
                    .serve_dioxus_application(&quot;&quot;, ServeConfigBuilder::new(app, ()))
                    .into_make_service(),
            )
            .await
            .unwrap();
    }
}

fn app(cx: Scope) -&gt; Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    })
}
</code></pre></pre>
<p>Now, run your app with <code>cargo run</code> and open <code>http://localhost:8080</code> in your browser. You should see a server-side rendered page with a counter.</p>
<h2 id="hydration"><a class="header" href="#hydration">Hydration</a></h2>
<p>Right now, the page is static. We can't interact with the buttons. To fix this, we can hydrate the page with <code>dioxus-web</code>.</p>
<p>First, modify your <code>Cargo.toml</code> to include two features, one for the server called <code>ssr</code>, and one for the client called <code>web</code>.</p>
<pre><code class="language-toml">[dependencies]
# Common dependancies
dioxus = { version = &quot;*&quot; }
dioxus-fullstack = { version = &quot;*&quot; }

# Web dependancies
dioxus-web = { version = &quot;*&quot;, features=[&quot;hydrate&quot;], optional = true }

# Server dependancies
axum = { version = &quot;0.6.12&quot;, optional = true }
tokio = { version = &quot;1.27.0&quot;, features = [&quot;full&quot;], optional = true }

[features]
default = []
ssr = [&quot;axum&quot;, &quot;tokio&quot;, &quot;dioxus-fullstack/axum&quot;]
web = [&quot;dioxus-web&quot;]
</code></pre>
<p>Next, we need to modify our <code>main.rs</code> to use either hydrate on the client or render on the server depending on the active features.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case, unused)]
use dioxus::prelude::*;

fn main() {
    #[cfg(feature = &quot;web&quot;)]
    dioxus_web::launch_cfg(app, dioxus_web::Config::new().hydrate(true));
    #[cfg(feature = &quot;ssr&quot;)]
    {
        use dioxus_fullstack::prelude::*;
        tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async move {
                let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8080));
                axum::Server::bind(&amp;addr)
                    .serve(
                        axum::Router::new()
                            .serve_dioxus_application(&quot;&quot;, ServeConfigBuilder::new(app, ()))
                            .into_make_service(),
                    )
                    .await
                    .unwrap();
            });
    }
}

fn app(cx: Scope) -&gt; Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    })
}
</code></pre></pre>
<p>Now, build your client-side bundle with <code>dioxus build --features web</code> and run your server with <code>cargo run --features ssr</code>. You should see the same page as before, but now you can interact with the buttons!</p>
<h2 id="sycronizing-props-between-the-server-and-client"><a class="header" href="#sycronizing-props-between-the-server-and-client">Sycronizing props between the server and client</a></h2>
<p>Let's make the initial count of the counter dynamic based on the current page.</p>
<h3 id="modifying-the-server"><a class="header" href="#modifying-the-server">Modifying the server</a></h3>
<p>To do this, we must remove the serve_dioxus_application and replace it with a custom implementation of its four key functions:</p>
<ul>
<li>Serve static WASM and JS files with serve_static_assets</li>
<li>Register server functions with register_server_fns (more information on server functions later)</li>
<li>Connect to the hot reload server with connect_hot_reload</li>
<li>A custom route that uses SSRState to server-side render the application</li>
</ul>
<h3 id="modifying-the-client"><a class="header" href="#modifying-the-client">Modifying the client</a></h3>
<p>The only thing we need to change on the client is the props. <code>dioxus-fullstack</code> will automatically serialize the props it uses to server render the app and send them to the client. In the client section of <code>main.rs</code>, we need to add <code>get_root_props_from_document</code> to deserialize the props before we hydrate the app.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case, unused)]
use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    #[cfg(feature = &quot;web&quot;)]
    dioxus_web::launch_with_props(
        app,
        // Get the root props from the document
        get_root_props_from_document().unwrap_or_default(),
        dioxus_web::Config::new().hydrate(true),
    );
    #[cfg(feature = &quot;ssr&quot;)]
    {
        use axum::extract::Path;
        use axum::extract::State;
        use axum::routing::get;
        tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async move {
                let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8080));
                axum::Server::bind(&amp;addr)
                    .serve(
                        axum::Router::new()
                            // Serve the dist folder with the static javascript and WASM files created by the dixous CLI
                            .serve_static_assets(&quot;./dist&quot;)
                            // Register server functions
                            .register_server_fns(&quot;&quot;)
                            // Connect to the hot reload server in debug mode
                            .connect_hot_reload()
                            // Render the application. This will serialize the root props (the intial count) into the HTML
                            .route(
                                &quot;/&quot;,
                                get(move | State(ssr_state): State&lt;SSRState&gt;| async move { axum::body::Full::from(
                                    ssr_state.render(
                                        &amp;ServeConfigBuilder::new(
                                            app,
                                            0,
                                        )
                                        .build(),
                                    )
                                )}),
                            )
                            // Render the application with a different intial count
                            .route(
                                &quot;/:initial_count&quot;,
                                get(move |Path(intial_count): Path&lt;usize&gt;, State(ssr_state): State&lt;SSRState&gt;| async move { axum::body::Full::from(
                                    ssr_state.render(
                                        &amp;ServeConfigBuilder::new(
                                            app,
                                            intial_count,
                                        )
                                        .build(),
                                    )
                                )}),
                            )
                            .with_state(SSRState::default())
                            .into_make_service(),
                    )
                    .await
                    .unwrap();
            });
    }
}

fn app(cx: Scope&lt;usize&gt;) -&gt; Element {
    let mut count = use_state(cx, || *cx.props);

    cx.render(rsx! {
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    })
}
</code></pre></pre>
<p>Now, build your client-side bundle with <code>dioxus build --features web</code> and run your server with <code>cargo run --features ssr</code>. Navigate to <code>http://localhost:8080/1</code> and you should see the counter start at 1. Navigate to <code>http://localhost:8080/2</code> and you should see the counter start at 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communicating-with-the-server"><a class="header" href="#communicating-with-the-server">Communicating with the server</a></h1>
<p><code>dixous-server</code> provides server functions that allow you to call an automatically generated API on the server from the client as if it were a local function.</p>
<p>To make a server function, simply add the <code>#[server(YourUniqueType)]</code> attribute to a function. The function must:</p>
<ul>
<li>Be an async function</li>
<li>Have arguments and a return type that both implement serialize and deserialize (with <a href="https://serde.rs/">serde</a>).</li>
<li>Return a <code>Result</code> with an error type of ServerFnError</li>
</ul>
<p>You must call <code>register</code> on the type you passed into the server macro in your main function before starting your server to tell Dioxus about the server function.</p>
<p>Let's continue building on the app we made in the <a href="fullstack/./getting_started.html">getting started</a> guide. We will add a server function to our app that allows us to double the count on the server.</p>
<p>First, add serde as a dependency:</p>
<pre><code class="language-shell">cargo add serde
</code></pre>
<p>Next, add the server function to your <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(non_snake_case, unused)]
use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    #[cfg(feature = &quot;web&quot;)]
    dioxus_web::launch_with_props(
        app,
        // Get the root props from the document
        get_root_props_from_document().unwrap_or_default(),
        dioxus_web::Config::new().hydrate(true),
    );
    #[cfg(feature = &quot;ssr&quot;)]
    {
        use axum::extract::Path;
        use axum::extract::State;
        use axum::routing::get;

        // Register the server function before starting the server
        DoubleServer::register().unwrap();

        tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async move {
                let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8080));
                axum::Server::bind(&amp;addr)
                    .serve(
                        axum::Router::new()
                            // Serve the dist folder with the static javascript and WASM files created by the dixous CLI
                            .serve_static_assets(&quot;./dist&quot;)
                            // Register server functions
                            .register_server_fns(&quot;&quot;)
                            // Connect to the hot reload server in debug mode
                            .connect_hot_reload()
                            // Render the application. This will serialize the root props (the intial count) into the HTML
                            .route(
                                &quot;/&quot;,
                                get(move |Path(intial_count): Path&lt;usize&gt;, State(ssr_state): State&lt;SSRState&gt;| async move { axum::body::Full::from(
                                    ssr_state.render(
                                        &amp;ServeConfigBuilder::new(
                                            app,
                                            intial_count,
                                        )
                                        .build(),
                                    )
                                )}),
                            )
                            // Render the application with a different intial count
                            .route(
                                &quot;/:initial_count&quot;,
                                get(move |Path(intial_count): Path&lt;usize&gt;, State(ssr_state): State&lt;SSRState&gt;| async move { axum::body::Full::from(
                                    ssr_state.render(
                                        &amp;ServeConfigBuilder::new(
                                            app,
                                            intial_count,
                                        )
                                        .build(),
                                    )
                                )}),
                            )
                            .with_state(SSRState::default())
                            .into_make_service(),
                    )
                    .await
                    .unwrap();
            });
    }
}

fn app(cx: Scope&lt;usize&gt;) -&gt; Element {
    let mut count = use_state(cx, || *cx.props);

    cx.render(rsx! {
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
        button {
            onclick: move |_| {
                to_owned![count];
                async move {
                    // Call the server function just like a local async function
                    if let Ok(new_count) = double_server(*count.current()).await {
                        count.set(new_count);
                    }
                }
            },
            &quot;Double&quot;
        }
    })
}

#[server(DoubleServer)]
async fn double_server(number: usize) -&gt; Result&lt;usize, ServerFnError&gt; {
    // Perform some expensive computation or access a database on the server
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    let result = number * 2;
    println!(&quot;server calculated {result}&quot;);
    Ok(result)
}
</code></pre></pre>
<p>Now, build your client-side bundle with <code>dioxus build --features web</code> and run your server with <code>cargo run --features ssr</code>. You should see a new button that multiplies the count by 2.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>That's it! You've created a full-stack Dioxus app. You can find more examples of full-stack apps and information about how to integrate with other frameworks and desktop renderers in the <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/server/examples">dioxus-fullstack examples directory</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-renderer"><a class="header" href="#custom-renderer">Custom Renderer</a></h1>
<p>Dioxus is an incredibly portable framework for UI development. The lessons, knowledge, hooks, and components you acquire over time can always be used for future projects. However, sometimes those projects cannot leverage a supported renderer or you need to implement your own better renderer.</p>
<p>Great news: the design of the renderer is entirely up to you! We provide suggestions and inspiration with the 1st party renderers, but only really require processing <code>Mutations</code> and sending <code>UserEvents</code>.</p>
<h2 id="the-specifics"><a class="header" href="#the-specifics">The specifics:</a></h2>
<p>Implementing the renderer is fairly straightforward. The renderer needs to:</p>
<ol>
<li>Handle the stream of edits generated by updates to the virtual DOM</li>
<li>Register listeners and pass events into the virtual DOM's event system</li>
</ol>
<p>Essentially, your renderer needs to process edits and generate events to update the VirtualDOM. From there, you'll have everything needed to render the VirtualDOM to the screen.</p>
<p>Internally, Dioxus handles the tree relationship, diffing, memory management, and the event system, leaving as little as possible required for renderers to implement themselves.</p>
<p>For reference, check out the <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter">javascript interpreter</a> or <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui">tui renderer</a> as a starting point for your custom renderer.</p>
<h2 id="templates"><a class="header" href="#templates">Templates</a></h2>
<p>Dioxus is built around the concept of <a href="https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html">Templates</a>. Templates describe a UI tree known at compile time with dynamic parts filled at runtime. This is useful internally to make skip diffing static nodes, but it is also useful for the renderer to reuse parts of the UI tree. This can be useful for things like a list of items. Each item could contain some static parts and some dynamic parts. The renderer can use the template to create a static part of the UI once, clone it for each element in the list, and then fill in the dynamic parts.</p>
<h2 id="mutations"><a class="header" href="#mutations">Mutations</a></h2>
<p>The <code>Mutation</code> type is a serialized enum that represents an operation that should be applied to update the UI. The variants roughly follow this set:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Mutation {
    AppendChildren,
    AssignId,
    CreatePlaceholder,
    CreateTextNode,
    HydrateText,
    LoadTemplate,
    ReplaceWith,
    ReplacePlaceholder,
    InsertAfter,
    InsertBefore,
    SetAttribute,
    SetText,
    NewEventListener,
    RemoveEventListener,
    Remove,
    PushRoot,
}
<span class="boring">}
</span></code></pre></pre>
<p>The Dioxus diffing mechanism operates as a <a href="https://en.wikipedia.org/wiki/Stack_machine">stack machine</a> where the <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate">LoadTemplate</a>, <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreatePlaceholder">CreatePlaceholder</a>, and <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreateTextNode">CreateTextNode</a> mutations pushes a new &quot;real&quot; DOM node onto the stack and <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.AppendChildren">AppendChildren</a>, <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertAfter">InsertAfter</a>, <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertBefore">InsertBefore</a>, <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplacePlaceholder">ReplacePlaceholder</a>, and <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplaceWith">ReplaceWith</a> all remove nodes from the stack.</p>
<h2 id="node-storage"><a class="header" href="#node-storage">Node storage</a></h2>
<p>Dioxus saves and loads elements with IDs. Inside the VirtualDOM, this is just tracked as as a u64.</p>
<p>Whenever a <code>CreateElement</code> edit is generated during diffing, Dioxus increments its node counter and assigns that new element its current NodeCount. The RealDom is responsible for remembering this ID and pushing the correct node when id is used in a mutation. Dioxus reclaims the IDs of elements when removed. To stay in sync with Dioxus you can use a sparse Vec (Vec&lt;Option<T>&gt;) with possibly unoccupied items. You can use the ids as indexes into the Vec for elements, and grow the Vec when an id does not exist.</p>
<h3 id="an-example"><a class="header" href="#an-example">An Example</a></h3>
<p>For the sake of understanding, let's consider this example – a very simple UI declaration:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!( h1 {&quot;count: {x}&quot;} )
<span class="boring">}
</span></code></pre></pre>
<h4 id="building-templates"><a class="header" href="#building-templates">Building Templates</a></h4>
<p>The above rsx will create a template that contains one static h1 tag and a placeholder for a dynamic text node. The template contains the static parts of the UI, and ids for the dynamic parts along with the paths to access them.</p>
<p>The template will look something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Template {
    // Some id that is unique for the entire project
    name: &quot;main.rs:1:1:0&quot;,
    // The root nodes of the template
    roots: &amp;[
        TemplateNode::Element {
            tag: &quot;h1&quot;,
            namespace: None,
            attrs: &amp;[],
            children: &amp;[
                TemplateNode::DynamicText {
                    id: 0
                },
            ],
        }
    ],
    // the path to each of the dynamic nodes
    node_paths: &amp;[
        // the path to dynamic node with a id of 0
        &amp;[
            // on the first root node
            0,
            // the first child of the root node
            0,
        ]
    ],
    // the path to each of the dynamic attributes
    attr_paths: &amp;'a [&amp;'a [u8]],
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>For more detailed docs about the struture of templates see the <a href="https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html">Template api docs</a></p>
</blockquote>
<p>This template will be sent to the renderer in the <a href="https://docs.rs/dioxus-core/latest/dioxus_core/struct.Mutations.html#structfield.templates">list of templates</a> supplied with the mutations the first time it is used. Any time the renderer encounters a <a href="https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate">LoadTemplate</a> mutation after this, it should clone the template and store it in the given id.</p>
<p>For dynamic nodes and dynamic text nodes, a placeholder node should be created and inserted into the UI so that the node can be modified later.</p>
<p>In HTML renderers, this template could look like this:</p>
<pre><code class="language-html">&lt;h1&gt;&quot;&quot;&lt;/h1&gt;
</code></pre>
<h4 id="applying-mutations"><a class="header" href="#applying-mutations">Applying Mutations</a></h4>
<p>After the renderer has created all of the new templates, it can begin to process the mutations.</p>
<p>When the renderer starts, it should contain the Root node on the stack and store the Root node with an id of 0. The Root node is the top-level node of the UI. In HTML, this is the <code>&lt;div id=&quot;main&quot;&gt;</code> element.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instructions: []
stack: [
    RootNode,
]
nodes: [
    RootNode,
]
<span class="boring">}
</span></code></pre></pre>
<p>The first mutation is a <code>LoadTemplate</code> mutation. This tells the renderer to load a root from the template with the given id. The renderer will then push the root node of the template onto the stack and store it with an id for later. In this case, the root node is an h1 element.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instructions: [
    LoadTemplate {
        // the id of the template
        name: &quot;main.rs:1:1:0&quot;,
        // the index of the root node in the template
        index: 0,
        // the id to store
        id: ElementId(1),
    }
]
stack: [
    RootNode,
    &lt;h1&gt;&quot;&quot;&lt;/h1&gt;,
]
nodes: [
    RootNode,
    &lt;h1&gt;&quot;&quot;&lt;/h1&gt;,
]
<span class="boring">}
</span></code></pre></pre>
<p>Next, Dioxus will create the dynamic text node. The diff algorithm decides that this node needs to be created, so Dioxus will generate the Mutation <code>HydrateText</code>. When the renderer receives this instruction, it will navigate to the placeholder text node in the template and replace it with the new text.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instructions: [
    LoadTemplate {
        name: &quot;main.rs:1:1:0&quot;,
        index: 0,
        id: ElementId(1),
    },
    HydrateText {
        // the id to store the text node
        id: ElementId(2),
        // the text to set
        text: &quot;count: 0&quot;,
    }
]
stack: [
    RootNode,
    &lt;h1&gt;&quot;count: 0&quot;&lt;/h1&gt;,
]
nodes: [
    RootNode,
    &lt;h1&gt;&quot;count: 0&quot;&lt;/h1&gt;,
    &quot;count: 0&quot;,
]
<span class="boring">}
</span></code></pre></pre>
<p>Remember, the h1 node is not attached to anything (it is unmounted) so Dioxus needs to generate an Edit that connects the h1 node to the Root. It depends on the situation, but in this case, we use <code>AppendChildren</code>. This pops the text node off the stack, leaving the Root element as the next element on the stack.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>instructions: [
    LoadTemplate {
        name: &quot;main.rs:1:1:0&quot;,
        index: 0,
        id: ElementId(1),
    },
    HydrateText {
        id: ElementId(2),
        text: &quot;count: 0&quot;,
    },
    AppendChildren {
        // the id of the parent node
        id: ElementId(0),
        // the number of nodes to pop off the stack and append
        m: 1
    }
]
stack: [
    RootNode,
]
nodes: [
    RootNode,
    &lt;h1&gt;&quot;count: 0&quot;&lt;/h1&gt;,
    &quot;count: 0&quot;,
]
<span class="boring">}
</span></code></pre></pre>
<p>Over time, our stack looked like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[Root]
[Root, &lt;h1&gt;&quot;&quot;&lt;/h1&gt;]
[Root, &lt;h1&gt;&quot;count: 0&quot;&lt;/h1&gt;]
[Root]
<span class="boring">}
</span></code></pre></pre>
<p>Conveniently, this approach completely separates the Virtual DOM and the Real DOM. Additionally, these edits are serializable, meaning we can even manage UIs across a network connection. This little stack machine and serialized edits make Dioxus independent of platform specifics.</p>
<p>Dioxus is also really fast. Because Dioxus splits the diff and patch phase, it's able to make all the edits to the RealDOM in a very short amount of time (less than a single frame) making rendering very snappy. It also allows Dioxus to cancel large diffing operations if higher priority work comes in while it's diffing.</p>
<p>This little demo serves to show exactly how a Renderer would need to process a mutation stream to build UIs.</p>
<h2 id="event-loop"><a class="header" href="#event-loop">Event loop</a></h2>
<p>Like most GUIs, Dioxus relies on an event loop to progress the VirtualDOM. The VirtualDOM itself can produce events as well, so it's important for your custom renderer can handle those too.</p>
<p>The code for the WebSys implementation is straightforward, so we'll add it here to demonstrate how simple an event loop is:</p>
<pre><code class="language-rust  ignore">pub async fn run(&amp;mut self) -&gt; dioxus_core::error::Result&lt;()&gt; {
    // Push the body element onto the WebsysDom's stack machine
    let mut websys_dom = crate::new::WebsysDom::new(prepare_websys_dom());
    websys_dom.stack.push(root_node);

    // Rebuild or hydrate the virtualdom
    let mutations = self.internal_dom.rebuild();
    websys_dom.apply_mutations(mutations);

    // Wait for updates from the real dom and progress the virtual dom
    loop {
        let user_input_future = websys_dom.wait_for_event();
        let internal_event_future = self.internal_dom.wait_for_work();

        match select(user_input_future, internal_event_future).await {
            Either::Left((_, _)) =&gt; {
                let mutations = self.internal_dom.work_with_deadline(|| false);
                websys_dom.apply_mutations(mutations);
            },
            Either::Right((event, _)) =&gt; websys_dom.handle_event(event),
        }

        // render
    }
}
</code></pre>
<p>It's important to decode what the real events are for your event system into Dioxus' synthetic event system (synthetic meaning abstracted). This simply means matching your event type and creating a Dioxus <code>UserEvent</code> type. Right now, the virtual event system is modeled almost entirely around the HTML spec, but we are interested in slimming it down.</p>
<pre><code class="language-rust  ignore">fn virtual_event_from_websys_event(event: &amp;web_sys::Event) -&gt; VirtualEvent {
    match event.type_().as_str() {
        &quot;keydown&quot; =&gt; {
            let event: web_sys::KeyboardEvent = event.clone().dyn_into().unwrap();
            UserEvent::KeyboardEvent(UserEvent {
                scope_id: None,
                priority: EventPriority::Medium,
                name: &quot;keydown&quot;,
                // This should be whatever element is focused
                element: Some(ElementId(0)),
                data: Arc::new(KeyboardData{
                    char_code: event.char_code(),
                    key: event.key(),
                    key_code: event.key_code(),
                    alt_key: event.alt_key(),
                    ctrl_key: event.ctrl_key(),
                    meta_key: event.meta_key(),
                    shift_key: event.shift_key(),
                    location: event.location(),
                    repeat: event.repeat(),
                    which: event.which(),
                })
            })
        }
        _ =&gt; todo!()
    }
}
</code></pre>
<h2 id="custom-raw-elements"><a class="header" href="#custom-raw-elements">Custom raw elements</a></h2>
<p>If you need to go as far as relying on custom elements/attributes for your renderer – you totally can. This still enables you to use Dioxus' reactive nature, component system, shared state, and other features, but will ultimately generate different nodes. All attributes and listeners for the HTML and SVG namespace are shuttled through helper structs that essentially compile away. You can drop in your elements any time you want, with little hassle. However, you must be sure your renderer can handle the new namespace.</p>
<p>For more examples and information on how to create custom namespaces, see the <a href="https://github.com/DioxusLabs/dioxus/blob/master/packages/html/README.md#how-to-extend-it"><code>dioxus_html</code> crate</a>.</p>
<h1 id="native-core"><a class="header" href="#native-core">Native Core</a></h1>
<p>If you are creating a renderer in rust, the <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core">native-core</a> crate provides some utilities to implement a renderer. It provides an abstraction over Mutations and Templates and contains helpers that can handle the layout and text editing for you.</p>
<h2 id="the-realdom"><a class="header" href="#the-realdom">The RealDom</a></h2>
<p>The <code>RealDom</code> is a higher-level abstraction over updating the Dom. It uses an entity component system to manage the state of nodes. This system allows you to modify insert and modify arbitrary components on nodes. On top of this, the RealDom provides a way to manage a tree of nodes, and the State trait provides a way to automatically add and update these components when the tree is modified. It also provides a way to apply <code>Mutations</code> to the RealDom.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let's build a toy renderer with borders, size, and text color.
Before we start let's take a look at an example element we can render:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!{
    div{
        color: &quot;red&quot;,
        p{
            border: &quot;1px solid black&quot;,
            &quot;hello world&quot;
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>In this tree, the color depends on the parent's color. The layout depends on the children's layout, the current text, and the text size. The border depends on only the current node.</p>
<p>In the following diagram arrows represent dataflow:</p>
<p><a href="https://mermaid.live/edit#pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ"><img src="https://mermaid.ink/img/pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ?type=png" alt="" /></a></p>
<p>To help in building a Dom, native-core provides the State trait and a RealDom struct. The State trait provides a way to describe how states in a node depend on other states in its relatives. By describing how to update a single node from its relations, native-core will derive a way to update the states of all nodes for you. Once you have a state you can provide it as a generic to RealDom. RealDom provides all of the methods to interact and update your new dom.</p>
<p>Native Core cannot create all of the required methods for the State trait, but it can derive some of them. To implement the State trait, you must implement the following methods and let the <code>#[partial_derive_state]</code> macro handle the rest:</p>
<pre><code class="language-rust  ignore">// All states must derive Component (https://docs.rs/shipyard/latest/shipyard/derive.Component.html)
// They also must implement Default or provide a custom implementation of create in the State trait
#[derive(Default, Component)]
struct MyState;

/// Derive some of the boilerplate for the State implementation
#[partial_derive_state]
impl State for MyState {
    // The states of the parent nodes this state depends on
    type ParentDependencies = ();

    // The states of the child nodes this state depends on
    type ChildDependencies = (Self,);

    // The states of the current node this state depends on
    type NodeDependencies = ();

    // The parts of the current text, element, or placeholder node in the tree that this state depends on
    const NODE_MASK: NodeMaskBuilder&lt;'static&gt; = NodeMaskBuilder::new();

    // How to update the state of the current node based on the state of the parent nodes, child nodes, and the current node
    // Returns true if the node was updated and false if the node was not updated
    fn update&lt;'a&gt;(
        &amp;mut self,
        // The view of the current node limited to the parts this state depends on
        _node_view: NodeView&lt;()&gt;,
        // The state of the current node that this state depends on
        _node: &lt;Self::NodeDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;,
        // The state of the parent nodes that this state depends on
        _parent: Option&lt;&lt;Self::ParentDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        // The state of the child nodes that this state depends on
        _children: Vec&lt;&lt;Self::ChildDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        // The context of the current node used to pass global state into the tree
        _context: &amp;SendAnyMap,
    ) -&gt; bool {
        todo!()
    }

    // partial_derive_state will generate a default implementation of all the other methods
}
</code></pre>
<p>Lets take a look at how to implement the State trait for a simple renderer.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FontSize(f64);

// All states need to derive Component
#[derive(Default, Debug, Copy, Clone, Component)]
struct Size(f64, f64);

/// Derive some of the boilerplate for the State implementation
#[partial_derive_state]
impl State for Size {
    type ParentDependencies = ();

    // The size of the current node depends on the size of its children
    type ChildDependencies = (Self,);

    type NodeDependencies = ();

    // Size only cares about the width, height, and text parts of the current node
    const NODE_MASK: NodeMaskBuilder&lt;'static&gt; = NodeMaskBuilder::new()
        // Get access to the width and height attributes
        .with_attrs(AttributeMaskBuilder::Some(&amp;[&quot;width&quot;, &quot;height&quot;]))
        // Get access to the text of the node
        .with_text();

    fn update&lt;'a&gt;(
        &amp;mut self,
        node_view: NodeView&lt;()&gt;,
        _node: &lt;Self::NodeDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;,
        _parent: Option&lt;&lt;Self::ParentDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        children: Vec&lt;&lt;Self::ChildDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        context: &amp;SendAnyMap,
    ) -&gt; bool {
        let font_size = context.get::&lt;FontSize&gt;().unwrap().0;
        let mut width;
        let mut height;
        if let Some(text) = node_view.text() {
            // if the node has text, use the text to size our object
            width = text.len() as f64 * font_size;
            height = font_size;
        } else {
            // otherwise, the size is the maximum size of the children
            width = children
                .iter()
                .map(|(item,)| item.0)
                .reduce(|accum, item| if accum &gt;= item { accum } else { item })
                .unwrap_or(0.0);

            height = children
                .iter()
                .map(|(item,)| item.1)
                .reduce(|accum, item| if accum &gt;= item { accum } else { item })
                .unwrap_or(0.0);
        }
        // if the node contains a width or height attribute it overrides the other size
        for a in node_view.attributes().into_iter().flatten() {
            match &amp;*a.attribute.name {
                &quot;width&quot; =&gt; width = a.value.as_float().unwrap(),
                &quot;height&quot; =&gt; height = a.value.as_float().unwrap(),
                // because Size only depends on the width and height, no other attributes will be passed to the member
                _ =&gt; panic!(),
            }
        }
        // to determine what other parts of the dom need to be updated we return a boolean that marks if this member changed
        let changed = (width != self.0) || (height != self.1);
        *self = Self(width, height);
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Component)]
struct TextColor {
    r: u8,
    g: u8,
    b: u8,
}

#[partial_derive_state]
impl State for TextColor {
    // TextColor depends on the TextColor part of the parent
    type ParentDependencies = (Self,);

    type ChildDependencies = ();

    type NodeDependencies = ();

    // TextColor only cares about the color attribute of the current node
    const NODE_MASK: NodeMaskBuilder&lt;'static&gt; =
        // Get access to the color attribute
        NodeMaskBuilder::new().with_attrs(AttributeMaskBuilder::Some(&amp;[&quot;color&quot;]));

    fn update&lt;'a&gt;(
        &amp;mut self,
        node_view: NodeView&lt;()&gt;,
        _node: &lt;Self::NodeDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;,
        parent: Option&lt;&lt;Self::ParentDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        _children: Vec&lt;&lt;Self::ChildDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        _context: &amp;SendAnyMap,
    ) -&gt; bool {
        // TextColor only depends on the color tag, so getting the first tag is equivilent to looking through all tags
        let new = match node_view
            .attributes()
            .and_then(|mut attrs| attrs.next())
            .and_then(|attr| attr.value.as_text())
        {
            // if there is a color tag, translate it
            Some(&quot;red&quot;) =&gt; TextColor { r: 255, g: 0, b: 0 },
            Some(&quot;green&quot;) =&gt; TextColor { r: 0, g: 255, b: 0 },
            Some(&quot;blue&quot;) =&gt; TextColor { r: 0, g: 0, b: 255 },
            Some(color) =&gt; panic!(&quot;unknown color {color}&quot;),
            // otherwise check if the node has a parent and inherit that color
            None =&gt; match parent {
                Some((parent,)) =&gt; *parent,
                None =&gt; Self::default(),
            },
        };
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Component)]
struct Border(bool);

#[partial_derive_state]
impl State for Border {
    // TextColor depends on the TextColor part of the parent
    type ParentDependencies = (Self,);

    type ChildDependencies = ();

    type NodeDependencies = ();

    // Border does not depended on any other member in the current node
    const NODE_MASK: NodeMaskBuilder&lt;'static&gt; =
        // Get access to the border attribute
        NodeMaskBuilder::new().with_attrs(AttributeMaskBuilder::Some(&amp;[&quot;border&quot;]));

    fn update&lt;'a&gt;(
        &amp;mut self,
        node_view: NodeView&lt;()&gt;,
        _node: &lt;Self::NodeDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;,
        _parent: Option&lt;&lt;Self::ParentDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        _children: Vec&lt;&lt;Self::ChildDependencies as Dependancy&gt;::ElementBorrowed&lt;'a&gt;&gt;,
        _context: &amp;SendAnyMap,
    ) -&gt; bool {
        // check if the node contians a border attribute
        let new = Self(
            node_view
                .attributes()
                .and_then(|mut attrs| attrs.next().map(|a| a.attribute.name == &quot;border&quot;))
                .is_some(),
        );
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have our state, we can put it to use in our RealDom. We can update the RealDom with apply_mutations to update the structure of the dom (adding, removing, and changing properties of nodes) and then update_state to update the States for each of the nodes that changed.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    fn app(cx: Scope) -&gt; Element {
        let count = use_state(cx, || 0);

        use_future(cx, (count,), |(count,)| async move {
            loop {
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                count.set(*count + 1);
            }
        });

        cx.render(rsx! {
            div{
                color: &quot;red&quot;,
                &quot;{count}&quot;
            }
        })
    }

    // create the vdom, the real_dom, and the binding layer between them
    let mut vdom = VirtualDom::new(app);
    let mut rdom: RealDom = RealDom::new([
        Border::to_type_erased(),
        TextColor::to_type_erased(),
        Size::to_type_erased(),
    ]);
    let mut dioxus_intigration_state = DioxusState::create(&amp;mut rdom);

    let mutations = vdom.rebuild();
    // update the structure of the real_dom tree
    dioxus_intigration_state.apply_mutations(&amp;mut rdom, mutations);
    let mut ctx = SendAnyMap::new();
    // set the font size to 3.3
    ctx.insert(FontSize(3.3));
    // update the State for nodes in the real_dom tree
    let _to_rerender = rdom.update_state(ctx);

    // we need to run the vdom in a async runtime
    tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?
        .block_on(async {
            loop {
                // wait for the vdom to update
                vdom.wait_for_work().await;

                // get the mutations from the vdom
                let mutations = vdom.render_immediate();

                // update the structure of the real_dom tree
                dioxus_intigration_state.apply_mutations(&amp;mut rdom, mutations);

                // update the state of the real_dom tree
                let mut ctx = SendAnyMap::new();
                // set the font size to 3.3
                ctx.insert(FontSize(3.3));
                let _to_rerender = rdom.update_state(ctx);

                // render...
                rdom.traverse_depth_first(|node| {
                    let indent = &quot; &quot;.repeat(node.height() as usize);
                    let color = *node.get::&lt;TextColor&gt;().unwrap();
                    let size = *node.get::&lt;Size&gt;().unwrap();
                    let border = *node.get::&lt;Border&gt;().unwrap();
                    let id = node.id();
                    let node = node.node_type();
                    let node_type = &amp;*node;
                    println!(&quot;{indent}{id:?} {color:?} {size:?} {border:?} {node_type:?}&quot;);
                });
            }
        })
}
</code></pre></pre>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>For most platforms, the layout of the Elements will stay the same. The <a href="https://docs.rs/dioxus-native-core/latest/dioxus_native_core/layout_attributes/index.html">layout_attributes</a> module provides a way to apply HTML attributes a <a href="https://docs.rs/taffy/latest/taffy/index.html">Taffy</a> layout style.</p>
<h2 id="text-editing"><a class="header" href="#text-editing">Text Editing</a></h2>
<p>To make it easier to implement text editing in rust renderers, <code>native-core</code> also contains a renderer-agnostic cursor system. The cursor can handle text editing, selection, and movement with common keyboard shortcuts integrated.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn text_editing() {
    let mut cursor = Cursor::default();
    let mut text = String::new();

    // handle keyboard input with a max text length of 10
    cursor.handle_input(
        &amp;Code::ArrowRight,
        &amp;Key::ArrowRight,
        &amp;Modifiers::empty(),
        &amp;mut text,
        10,
    );

    // mannually select text between characters 0-5 on the first line (this could be from dragging with a mouse)
    cursor.start = Pos::new(0, 0);
    cursor.end = Some(Pos::new(5, 0));

    // delete the selected text and move the cursor to the start of the selection
    cursor.delete_selection(&amp;mut text);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>That should be it! You should have nearly all the knowledge required on how to implement your renderer. We're super interested in seeing Dioxus apps brought to custom desktop renderers, mobile renderers, video game UI, and even augmented reality! If you're interested in contributing to any of these projects, don't be afraid to reach out or join the <a href="https://discord.gg/XgGxMSkvUM">community</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Development happens in the <a href="https://github.com/DioxusLabs/dioxus">Dioxus GitHub repository</a>. If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't <a href="https://github.com/DioxusLabs/dioxus/issues">done it already</a>).</p>
<p><a href="https://github.com/DioxusLabs/dioxus/discussions">GitHub discussions</a> can be used as a place to ask for help or talk about features. You can also join <a href="https://discord.gg/XgGxMSkvUM">our Discord channel</a> where some development discussion happens.</p>
<h2 id="improving-docs"><a class="header" href="#improving-docs">Improving Docs</a></h2>
<p>If you'd like to improve the docs, PRs are welcome! Both Rust docs (<a href="https://github.com/DioxusLabs/dioxus/tree/master/packages">source</a>) and this guide (<a href="https://github.com/DioxusLabs/dioxus/tree/master/docs/guide">source</a>) can be found in the GitHub repo.</p>
<h2 id="working-on-the-ecosystem"><a class="header" href="#working-on-the-ecosystem">Working on the Ecosystem</a></h2>
<p>Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can <a href="https://www.npmjs.com/search?q=keywords:react-component">browse npm.js</a> for inspiration. Once you are done, add your library to the <a href="https://github.com/DioxusLabs/awesome-dioxus">awesome dioxus</a> list or share it in the <code>#I-made-a-thing</code> channel on <a href="https://discord.gg/XgGxMSkvUM">Discord</a>.</p>
<h2 id="bugs--features"><a class="header" href="#bugs--features">Bugs &amp; Features</a></h2>
<p>If you've fixed <a href="https://github.com/DioxusLabs/dioxus/issues">an open issue</a>, feel free to submit a PR! You can also take a look at <a href="contributing/./roadmap.html">the roadmap</a> and work on something in there. Consider <a href="https://discord.gg/XgGxMSkvUM">reaching out</a> to the team first to make sure everyone's on the same page, and you don't do useless work!</p>
<p>All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<p>The following tools can be helpful when developing Dioxus. Many of these tools are used in the CI pipeline. Running them locally before submitting a PR instead of waiting for CI can save time.</p>
<ul>
<li>All code is tested with <a href="https://doc.rust-lang.org/cargo/commands/cargo-test.html">cargo test</a></li>
</ul>
<pre><code class="language-sh">cargo fmt --all
</code></pre>
<ul>
<li>All code is formatted with <a href="https://github.com/rust-lang/rustfmt">rustfmt</a></li>
</ul>
<pre><code class="language-sh">cargo check --workspace --examples --tests
</code></pre>
<ul>
<li>All code is linted with <a href="https://doc.rust-lang.org/clippy/">Clippy</a></li>
</ul>
<pre><code class="language-sh">cargo clippy --workspace --examples --tests -- -D warnings
</code></pre>
<ul>
<li>Crates that use unsafe are checked for undefined behavior with <a href="https://github.com/rust-lang/miri">MIRI</a>. MIRI can be helpful to debug what unsafe code is causing issues. Only code that does not interact with system calls can be checked with MIRI. Currently, this is used for the two MIRI tests in <code>dioxus-core</code> and <code>dioxus-native-core</code>.</li>
</ul>
<pre><code class="language-sh">cargo miri test --package dioxus-core --test miri_stress
cargo miri test --package dioxus-native-core --test miri_native
</code></pre>
<ul>
<li><a href="https://rust-analyzer.github.io/">Rust analyzer</a> can be very helpful for quick feedback in your IDE.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-struture"><a class="header" href="#project-struture">Project Struture</a></h1>
<p>There are many packages in the Dioxus organization. This document will help you understand the purpose of each package and how they fit together.</p>
<h2 id="renderers"><a class="header" href="#renderers">Renderers</a></h2>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/desktop">Desktop</a>: A Render that Runs Dioxus applications natively, but renders them with the system webview</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/mobile">Mobile</a>: A Render that Runs Dioxus applications natively, but renders them with the system webview. This is currently a copy of the desktop render</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/Web">Web</a>: Renders Dioxus applications in the browser by compiling to WASM and manipulating the DOM</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview">Liveview</a>: A Render that Runs on the server, and renders using a websocket proxy in the browser</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/rink">Rink</a>: A Renderer that renders a HTML-like tree into a terminal</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui">TUI</a>: A Renderer that uses Rink to render a Dioxus application in a terminal</li>
<li><a href="https://github.com/DioxusLabs/blitz/tree/master/blitz-core">Blitz-Core</a>: An experimental native renderer that renders a HTML-like tree using WGPU.</li>
<li><a href="https://github.com/DioxusLabs/blitz">Blitz</a>: An experimental native renderer that uses Blitz-Core to render a Dioxus application using WGPU.</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/ssr">SSR</a>: A Render that Runs Dioxus applications on the server, and renders them to HTML</li>
</ul>
<h2 id="state-managementhooks"><a class="header" href="#state-managementhooks">State Management/Hooks</a></h2>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks">Hooks</a>: A collection of common hooks for Dioxus applications</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/signals">Signals</a>: A experimental state management library for Dioxus applications. This currently contains a <code>Copy</code> version of UseRef</li>
<li><a href="https://github.com/DioxusLabs/dioxus-std">Dioxus STD</a>: A collection of platform agnostic hooks to interact with system interfaces (The clipboard, camera, etc.).</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/fermi">Fermi</a>: A global state management library for Dioxus applications.
<a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/router">Router</a>: A client-side router for Dioxus applications</li>
</ul>
<h2 id="core-utilities"><a class="header" href="#core-utilities">Core utilities</a></h2>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/core">core</a>: The core virtual dom implementation every Dioxus application uses
<ul>
<li>You can read more about the archetecture of the core <a href="https://dioxuslabs.com/blog/templates-diffing/">in this blog post</a> and the <a href="contributing/../custom_renderer/index.html">custom renderer section of the guide</a></li>
</ul>
</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/RSX">RSX</a>: The core parsing for RSX used for hot reloading, autoformatting, and the macro</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/core-macro">core-macro</a>: The rsx! macro used to write Dioxus applications. (This is a wrapper over the RSX crate)</li>
<li><a href="https://github.com/DioxusLabs/dioxus-html-macro">HTML macro</a>: A html-like alternative to the RSX macro</li>
</ul>
<h2 id="native-renderer-utilities"><a class="header" href="#native-renderer-utilities">Native Renderer Utilities</a></h2>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core">native-core</a>: Incrementally computed tree of states (mostly styles)
<ul>
<li>You can read more about how native-core can help you build native renderers in the <a href="contributing/../custom_renderer/index.html#native-core">custom renderer section of the guide</a></li>
</ul>
</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core-macro">native-core-macro</a>: A helper macro for native core</li>
<li><a href="https://github.com/DioxusLabs/taffy">Taffy</a>: Layout engine powering Blitz-Core, Rink, and Bevy UI</li>
</ul>
<h2 id="web-renderer-tooling"><a class="header" href="#web-renderer-tooling">Web renderer tooling</a></h2>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/html">HTML</a>: defines html specific elements, events, and attributes</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter">Interpreter</a>: defines browser bindings used by the web and desktop renderers</li>
</ul>
<h2 id="developer-tooling"><a class="header" href="#developer-tooling">Developer tooling</a></h2>
<ul>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/hot-reload">hot-reload</a>: Macro that uses the RSX crate to hot reload static parts of any rsx! macro. This macro works with any non-web renderer with an <a href="https://crates.io/crates/dioxus-hot-reload">integration</a></li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/autofmt">autofmt</a>: Formats RSX code</li>
<li><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/RSX-rosetta">rsx-rosetta</a>: Handles conversion between HTML and RSX</li>
<li><a href="https://github.com/DioxusLabs/cli">CLI</a>: A Command Line Interface and VSCode extension to assist with Dioxus usage</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walkthrough-of-the-hello-world-example-internals"><a class="header" href="#walkthrough-of-the-hello-world-example-internals">Walkthrough of the Hello World Example Internals</a></h1>
<p>This walkthrough will take you through the internals of the Hello World example program. It will explain how major parts of Dioxus internals interact with each other to take the readme example from a source file to a running application. This guide should serve as a high-level overview of the internals of Dioxus. It is not meant to be a comprehensive guide.</p>
<h2 id="the-source-file"><a class="header" href="#the-source-file">The Source File</a></h2>
<p>We start will a hello world program. This program renders a desktop app with the text &quot;Hello World&quot; in a webview.</p>
<pre><pre class="playground"><code class="language-rust edition2018">//! Example: README.md showcase
//!
//! The example from the README.md.

use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -&gt; Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    })
}
</code></pre></pre>
<p><a href="https://mermaid.live/edit#pako:eNqNkT1vwyAQhv8KvSlR48HphtQtqjK0S6tuSBGBS0CxwcJHk8rxfy_YVqxKVdR3ug_u4YXrQHmNwOFQ-bMyMhB7fReOJbVxfwyyMSy0l7GSpW1ARda727ksUy5MuSyKgvBC5ULA1h5N8WK_kCkfHWHgrBuiXsBynrvdsY9E3u1iM_eyvFOVVadMnELOap-o1911JLPHZ1b-YqLTc3LjTt7WifTZMJPsPdx1ov3Z_ellfcdL8R8vmTy5eUqsTUpZ-vzZzjAEK6gx1NLqtJwuNwSQwRoF8BRqGU4ChOvTORnJf3w7BZxCxBXERkvCjZXpQTXwg6zaVEVtyYe3cdvD0vsf4bucgw"><img src="https://mermaid.ink/img/pako:eNqNkT1vwyAQhv8KvSlR48HphtQtqjK0S6tuSBGBS0CxwcJHk8rxfy_YVqxKVdR3ug_u4YXrQHmNwOFQ-bMyMhB7fReOJbVxfwyyMSy0l7GSpW1ARda727ksUy5MuSyKgvBC5ULA1h5N8WK_kCkfHWHgrBuiXsBynrvdsY9E3u1iM_eyvFOVVadMnELOap-o1911JLPHZ1b-YqLTc3LjTt7WifTZMJPsPdx1ov3Z_ellfcdL8R8vmTy5eUqsTUpZ-vzZzjAEK6gx1NLqtJwuNwSQwRoF8BRqGU4ChOvTORnJf3w7BZxCxBXERkvCjZXpQTXwg6zaVEVtyYe3cdvD0vsf4bucgw?type=png" alt="" /></a></p>
<h2 id="the-rsx-macro"><a class="header" href="#the-rsx-macro">The rsx! Macro</a></h2>
<p>Before the Rust compiler runs the program, it will expand all macros. Here is what the hello world example looks like expanded:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -&gt; Element {
    let mut count = use_state(cx, || 0);

    cx.render(
        // rsx expands to LazyNodes::new
        ::dioxus::core::LazyNodes::new(
            move |__cx: &amp;::dioxus::core::ScopeState| -&gt; ::dioxus::core::VNode {
                // The template is every static part of the rsx
                static TEMPLATE: ::dioxus::core::Template = ::dioxus::core::Template {
                    // This is the source location of the rsx that generated this template. This is used to make hot rsx reloading work. Hot rsx reloading just replaces the template with a new one generated from the rsx by the CLI.
                    name: &quot;examples\\readme.rs:14:15:250&quot;,
                    // The root nodes are the top level nodes of the rsx
                    roots: &amp;[
                        // The h1 node
                        ::dioxus::core::TemplateNode::Element {
                            // Find the built in h1 tag in the dioxus_elements crate exported by the dioxus html crate
                            tag: dioxus_elements::h1::TAG_NAME,
                            namespace: dioxus_elements::h1::NAME_SPACE,
                            attrs: &amp;[],
                            // The children of the h1 node
                            children: &amp;[
                                // The dynamic count text node
                                // Any nodes that are dynamic have a dynamic placeholder with a unique index
                                ::dioxus::core::TemplateNode::DynamicText {
                                    // This index is used to find what element in `dynamic_nodes` to use instead of the placeholder
                                    id: 0usize,
                                },
                            ],
                        },
                        // The up high button node
                        ::dioxus::core::TemplateNode::Element {
                            tag: dioxus_elements::button::TAG_NAME,
                            namespace: dioxus_elements::button::NAME_SPACE,
                            attrs: &amp;[
                                // The dynamic onclick listener attribute
                                // Any attributes that are dynamic have a dynamic placeholder with a unique index.
                                ::dioxus::core::TemplateAttribute::Dynamic {
                                    // Similar to dynamic nodes, dynamic attributes have a unique index used to find the attribute in `dynamic_attrs` to use instead of the placeholder
                                    id: 0usize,
                                },
                            ],
                            children: &amp;[::dioxus::core::TemplateNode::Text { text: &quot;Up high!&quot; }],
                        },
                        // The down low button node
                        ::dioxus::core::TemplateNode::Element {
                            tag: dioxus_elements::button::TAG_NAME,
                            namespace: dioxus_elements::button::NAME_SPACE,
                            attrs: &amp;[
                                // The dynamic onclick listener attribute
                                ::dioxus::core::TemplateAttribute::Dynamic { id: 1usize },
                            ],
                            children: &amp;[::dioxus::core::TemplateNode::Text { text: &quot;Down low!&quot; }],
                        },
                    ],
                    // Node paths is a list of paths to every dynamic node in the rsx
                    node_paths: &amp;[
                        // The first node path is the path to the dynamic node with an id of 0 (the count text node)
                        &amp;[
                            // Go to the index 0 root node
                            0u8,
                            //
                            // Go to the first child of the root node
                            0u8,
                        ],
                    ],
                    // Attr paths is a list of paths to every dynamic attribute in the rsx
                    attr_paths: &amp;[
                        // The first attr path is the path to the dynamic attribute with an id of 0 (the up high button onclick listener)
                        &amp;[
                            // Go to the index 1 root node
                            1u8,
                        ],
                        // The second attr path is the path to the dynamic attribute with an id of 1 (the down low button onclick listener)
                        &amp;[
                            // Go to the index 2 root node
                            2u8,
                        ],
                    ],
                };
                // The VNode is a reference to the template with the dynamic parts of the rsx
                ::dioxus::core::VNode {
                    parent: None,
                    key: None,
                    // The static template this node will use. The template is stored in a Cell so it can be replaced with a new template when hot rsx reloading is enabled
                    template: std::cell::Cell::new(TEMPLATE),
                    root_ids: Default::default(),
                    dynamic_nodes: __cx.bump().alloc([
                        // The dynamic count text node (dynamic node id 0)
                        __cx.text_node(format_args!(&quot;High-Five counter: {0}&quot;, count)),
                    ]),
                    dynamic_attrs: __cx.bump().alloc([
                        // The dynamic up high button onclick listener (dynamic attribute id 0)
                        dioxus_elements::events::onclick(__cx, move |_| count += 1),
                        // The dynamic down low button onclick listener (dynamic attribute id 1)
                        dioxus_elements::events::onclick(__cx, move |_| count -= 1),
                    ]),
                }
            },
        ),
    )
}
</code></pre></pre>
<p>The rsx macro separates the static parts of the rsx (the template) and the dynamic parts (the dynamic_nodes and dynamic_attributes).</p>
<p>The static template only contains the parts of the rsx that cannot change at runtime with holes for the dynamic parts:</p>
<p><a href="https://mermaid.live/edit#pako:eNqdksFuwjAMhl8l8wkkKtFx65njdtm0E0GVSQKJoEmVOgKEeHecUrXStO0wn5Lf9u8vcm6ggjZQwf4UzspiJPH2Ib3g6NLuELG1oiMkp0TsLs9EDu2iUeSCH8tz2HJmy3lRFPrqsXGq9mxeLzcbCU6LZSUGXWRdwnY7tY7Tdoko-Dq1U64fODgiUfzJMeuOe7_ZGq-ny2jNhGQu9DqT8NUK6w72RcL8dxgdzv4PnHLAKf-Fk80HoBUDrfkqeBkTUd8EC2hMbNBpXtYtJySQNQ0PqPioMR4lSH_nOkwUPq9eQUUxmQWkViOZtUN-UwPVHk8dq0Y7CvH9uf3-E9wfrmuk1A"><img src="https://mermaid.ink/img/pako:eNqdksFuwjAMhl8l8wkkKtFx65njdtm0E0GVSQKJoEmVOgKEeHecUrXStO0wn5Lf9u8vcm6ggjZQwf4UzspiJPH2Ib3g6NLuELG1oiMkp0TsLs9EDu2iUeSCH8tz2HJmy3lRFPrqsXGq9mxeLzcbCU6LZSUGXWRdwnY7tY7Tdoko-Dq1U64fODgiUfzJMeuOe7_ZGq-ny2jNhGQu9DqT8NUK6w72RcL8dxgdzv4PnHLAKf-Fk80HoBUDrfkqeBkTUd8EC2hMbNBpXtYtJySQNQ0PqPioMR4lSH_nOkwUPq9eQUUxmQWkViOZtUN-UwPVHk8dq0Y7CvH9uf3-E9wfrmuk1A?type=png" alt="" /></a></p>
<p>The dynamic_nodes and dynamic_attributes are the parts of the rsx that can change at runtime:</p>
<p><a href="https://mermaid.live/edit#pako:eNp1UcFOwzAM_RXLVzZpvUbighDiABfgtkxTlnirtSaZUgc0df130hZEEcwny35-79nu0EZHqHDfxA9bmyTw9KIDlGjz7pDMqQZ3DsazhVCQ7dQbwnEiKxwDvN3NqhN4O4C3q_VaIztYKXjkQ7184HcCG3MQSgq6Mes1bjbTPAV3RdqIJN5l-V__2_Fcf5iY68dgG7ZHBT4WD5ftZfIBN7dQ_Tj4w1B9MVTXGZa_GMYdcIGekjfsymW7oaFRavKkUZXUmXTUqENfcCZLfD0Hi0pSpgXmkzNC92zKATyqvWnaUiXHEtPz9KrxY_0nzYOPmA"><img src="https://mermaid.ink/img/pako:eNp1UcFOwzAM_RXLVzZpvUbighDiABfgtkxTlnirtSaZUgc0df130hZEEcwny35-79nu0EZHqHDfxA9bmyTw9KIDlGjz7pDMqQZ3DsazhVCQ7dQbwnEiKxwDvN3NqhN4O4C3q_VaIztYKXjkQ7184HcCG3MQSgq6Mes1bjbTPAV3RdqIJN5l-V__2_Fcf5iY68dgG7ZHBT4WD5ftZfIBN7dQ_Tj4w1B9MVTXGZa_GMYdcIGekjfsymW7oaFRavKkUZXUmXTUqENfcCZLfD0Hi0pSpgXmkzNC92zKATyqvWnaUiXHEtPz9KrxY_0nzYOPmA?type=png" alt="" /></a></p>
<h2 id="launching-the-app"><a class="header" href="#launching-the-app">Launching the App</a></h2>
<p>The app is launched by calling the <code>launch</code> function with the root component. Internally, this function will create a new web view using <a href="https://docs.rs/wry/latest/wry/">wry</a> and create a virtual dom with the root component. This guide will not explain the renderer in-depth, but you can read more about it in the <a href="contributing//guide/custom-renderer">custom renderer</a> section.</p>
<h2 id="the-virtual-dom"><a class="header" href="#the-virtual-dom">The Virtual DOM</a></h2>
<p>Before we dive into the initial render in the virtual dom, we need to discuss what the virtual dom is. The virtual dom is a representation of the dom that is used to diff the current dom from the new dom. This diff is then used to create a list of mutations that need to be applied to the dom.</p>
<p>The Virtual Dom roughly looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VirtualDom {
    // All the templates that have been created or set durring hot reloading
    pub(crate) templates: FxHashMap&lt;TemplateId, FxHashMap&lt;usize, Template&lt;'static&gt;&gt;&gt;,

    // A slab of all the scopes that have been created
    pub(crate) scopes: ScopeSlab,

    // All scopes that have been marked as dirty
    pub(crate) dirty_scopes: BTreeSet&lt;DirtyScope&gt;,

    // Every element is actually a dual reference - one to the template and the other to the dynamic node in that template
    pub(crate) elements: Slab&lt;ElementRef&gt;,

    // This receiver is used to receive messages from hooks about what scopes need to be marked as dirty
    pub(crate) rx: futures_channel::mpsc::UnboundedReceiver&lt;SchedulerMsg&gt;,

    // The changes queued up to be sent to the renderer
    pub(crate) mutations: Mutations&lt;'static&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>What is a <a href="https://docs.rs/slab/latest/slab/">slab</a>?
A slab acts like a hashmap with integer keys if you don't care about the value of the keys. It is internally backed by a dense vector which makes it more efficient than a hashmap. When you insert a value into a slab, it returns an integer key that you can use to retrieve the value later.</p>
</blockquote>
<blockquote>
<p>How does Dioxus use slabs?
Dioxus uses &quot;synchronized slabs&quot; to communicate between the renderer and the VDOM. When an node is created in the Virtual Dom, a ElementId is passed along with the mutation to the renderer to identify the node. These ids are used by the Virtual Dom to reference that nodes in future mutations like setting an attribute on a node or removing a node.
When the renderer sends an event to the Virtual Dom, it sends the ElementId of the node that the event was triggered on. The Virtual Dom uses this id to find the node in the slab and then run the necessary event handlers.</p>
</blockquote>
<p>The virtual dom is a tree of scopes. A new scope is created for every component when it is first rendered and recycled when the component is unmounted.</p>
<p>Scopes serve three main purposes:</p>
<ol>
<li>They store the state of hooks used by the component</li>
<li>They store the state for the context API</li>
<li>They store the current and previous VNode that was rendered for diffing</li>
</ol>
<h3 id="the-initial-render"><a class="header" href="#the-initial-render">The Initial Render</a></h3>
<p>The root scope is created and rebuilt:</p>
<ol>
<li>The root component is run</li>
<li>The root component returns a VNode</li>
<li>Mutations for the VNode are created and added to the mutation list (this may involve creating new child components)</li>
<li>The VNode is stored in the root scope</li>
</ol>
<p>After the root scope is built, the mutations are sent to the renderer to be applied to the dom.</p>
<p>After the initial render, the root scope looks like this:</p>
<p><a href="https://mermaid.live/edit#pako:eNqtVE1P4zAQ_SuzPrWikRpWXCLtBRDisItWsOxhCaqM7RKricdyJrQV8N93QtvQNCkfEnOynydv3nxkHoVCbUQipjnOVSYDwc_L1AFbWd3dB-kzuEQkuFLoDUwDFkCZAek9nGDh0RlHK__atA1GkUUHf45f0YbppAqB_aOzIAvz-t7-chN_Y-1bw1WSJKsglIu2w9tktWXxIIuHURT5XCqTYa5NmDguw2R8c5MKq2GcgF46WTB_jafi9rZL0yi5q4jQTSrf9altO4okCn1Ratwyz55Qxuku2ITlTMgs6HCQimsPmb3PvqVi-L5gjXP3QcnxWnL8JZLrwGvR31n0KV-Bx6-r-oVkT_-3G1S-NQLbk9i8rj7udP2cixed2QcDCitHJiQw7ub3EVlNecrPjudG2-6soFO5VbMECmR9T5OnlUY4-AFxfw9aTFst3McU9TK1Otm6NEn_DubBYlX2_dglLXOz48FgwJmJ5lZTlhz6xWgNaFnyDgpymcARHO0W2a9J_l5w2wYXvHuGPcqaQ-rESBQmFNJq3nCPNZoK3l4sUSR81DLMUpG6Z_aTFeHV0imRUKjMSFReSzKnVnKGhUimMi8ZNdoShl-rlfmyOUfCS_cPcePz_B_Wl4pc"><img src="https://mermaid.ink/img/pako:eNqtVE1P4zAQ_SuzPrWikRpWXCLtBRDisItWsOxhCaqM7RKricdyJrQV8N93QtvQNCkfEnOynydv3nxkHoVCbUQipjnOVSYDwc_L1AFbWd3dB-kzuEQkuFLoDUwDFkCZAek9nGDh0RlHK__atA1GkUUHf45f0YbppAqB_aOzIAvz-t7-chN_Y-1bw1WSJKsglIu2w9tktWXxIIuHURT5XCqTYa5NmDguw2R8c5MKq2GcgF46WTB_jafi9rZL0yi5q4jQTSrf9altO4okCn1Ratwyz55Qxuku2ITlTMgs6HCQimsPmb3PvqVi-L5gjXP3QcnxWnL8JZLrwGvR31n0KV-Bx6-r-oVkT_-3G1S-NQLbk9i8rj7udP2cixed2QcDCitHJiQw7ub3EVlNecrPjudG2-6soFO5VbMECmR9T5OnlUY4-AFxfw9aTFst3McU9TK1Otm6NEn_DubBYlX2_dglLXOz48FgwJmJ5lZTlhz6xWgNaFnyDgpymcARHO0W2a9J_l5w2wYXvHuGPcqaQ-rESBQmFNJq3nCPNZoK3l4sUSR81DLMUpG6Z_aTFeHV0imRUKjMSFReSzKnVnKGhUimMi8ZNdoShl-rlfmyOUfCS_cPcePz_B_Wl4pc?type=png" alt="" /></a></p>
<h3 id="waiting-for-events"><a class="header" href="#waiting-for-events">Waiting for Events</a></h3>
<p>The Virtual Dom will only ever rerender a scope if it is marked as dirty. Each hook is responsible for marking the scope as dirty if the state has changed. Hooks can mark a scope as dirty by sending a message to the Virtual Dom's channel.</p>
<p>There are generally two ways a scope is marked as dirty:</p>
<ol>
<li>The renderer triggers an event: This causes an event listener to be called if needed which may mark a component as dirty</li>
<li>The renderer calls wait for work: This polls futures which may mark a component as dirty</li>
</ol>
<p>Once at least one scope is marked as dirty, the renderer can call <code>render_with_deadline</code> to diff the dirty scopes.</p>
<h3 id="diffing-scopes"><a class="header" href="#diffing-scopes">Diffing Scopes</a></h3>
<p>If the user clicked the &quot;up high&quot; button, the root scope would be marked as dirty by the use_state hook. Once the desktop renderer calls <code>render_with_deadline</code>, the root scope would be diffed.</p>
<p>To start the diffing process, the component is run. After the root component is run it will look like this:</p>
<p><a href="https://mermaid.live/edit#pako:eNrFVlFP2zAQ_iuen0BrpCaIl0i8AEJ72KQJtpcRFBnbJVYTn-U4tBXw33dpG5M2CetoBfdkny_ffb67fPIT5SAkjekkhxnPmHXk-3WiCVpZ3T9YZjJyDeDIDQcjycRCQVwmCTOGXEBhQEvtVvG1CWUldwo0-XX-6vVIF5W1GB9cWVbI1_PNL5v8jW3uPFbpmFOc2HK-GfA2WG1ZeJSFx0EQmJxxmUEupE01liEd394mVAkyjolYaFYgfu1P6N1dF8Yzua-cA51WphtTWzsLc872Zan9CnEGUkktuk6fFm_i5NxFRwn9bUimHrIvCT3-N2EBM70j5XBNOTwI5TrxmvQJkr7ELcHx67Jeggz0v92g8q0RaE-iP1193On6NyxecKUeJeFQaSdtTMLu_Xah5ctT_u94Nty2ZwU0zxWfxqQA5PecPq84kq9nfRw7SK0WDiEFZ4O37d34S_-08lFBVfb92KVb5HIrAp0WpjKYKeGyODLz0dohWIkaZNkiJqfkdLvIH6oRaTSoEmm0n06k0a5K0ZdpL61Io0Yt0nfpxc7UQ0_9cJrhyZ8syX-6brS706Mc489Vjja7fbWj3cxDqIdfJJqOaCFtwZTAV8hT7U0ovjBQRmiMS8HsNKGJfsE4Vjm4WWhOY2crOaKVEczJS8WwgAWNJywv0SuFcmB_rJ41y9fNiBqm_wA0MS9_AUuAiy0"><img src="https://mermaid.ink/img/pako:eNrFVlFP2zAQ_iuen0BrpCaIl0i8AEJ72KQJtpcRFBnbJVYTn-U4tBXw33dpG5M2CetoBfdkny_ffb67fPIT5SAkjekkhxnPmHXk-3WiCVpZ3T9YZjJyDeDIDQcjycRCQVwmCTOGXEBhQEvtVvG1CWUldwo0-XX-6vVIF5W1GB9cWVbI1_PNL5v8jW3uPFbpmFOc2HK-GfA2WG1ZeJSFx0EQmJxxmUEupE01liEd394mVAkyjolYaFYgfu1P6N1dF8Yzua-cA51WphtTWzsLc872Zan9CnEGUkktuk6fFm_i5NxFRwn9bUimHrIvCT3-N2EBM70j5XBNOTwI5TrxmvQJkr7ELcHx67Jeggz0v92g8q0RaE-iP1193On6NyxecKUeJeFQaSdtTMLu_Xah5ctT_u94Nty2ZwU0zxWfxqQA5PecPq84kq9nfRw7SK0WDiEFZ4O37d34S_-08lFBVfb92KVb5HIrAp0WpjKYKeGyODLz0dohWIkaZNkiJqfkdLvIH6oRaTSoEmm0n06k0a5K0ZdpL61Io0Yt0nfpxc7UQ0_9cJrhyZ8syX-6brS706Mc489Vjja7fbWj3cxDqIdfJJqOaCFtwZTAV8hT7U0ovjBQRmiMS8HsNKGJfsE4Vjm4WWhOY2crOaKVEczJS8WwgAWNJywv0SuFcmB_rJ41y9fNiBqm_wA0MS9_AUuAiy0?type=png" alt="" /></a></p>
<p>Next, the Virtual Dom will compare the new VNode with the previous VNode and only update the parts of the tree that have changed.</p>
<p>When a component is re-rendered, the Virtual Dom will compare the new VNode with the previous VNode and only update the parts of the tree that have changed.</p>
<p>The diffing algorithm goes through the list of dynamic attributes and nodes and compares them to the previous VNode. If the attribute or node has changed, a mutation that describes the change is added to the mutation list.</p>
<p>Here is what the diffing algorithm looks like for the root scope (red lines indicate that a mutation was generated, and green lines indicate that no mutation was generated)</p>
<p><a href="https://mermaid.live/edit#pako:eNrFlFFPwjAQx7_KpT7Kko2Elya8qCE-aGLAJ5khpe1Yw9Zbug4k4He3OJjbGPig0T5t17tf_nf777aEo5CEkijBNY-ZsfAwDjW4kxfzhWFZDGNECxOOmYTIYAo2lsCyDG4xzVBLbcv8_RHKSG4V6orSIN0Wxrh8b2RYKr_uTyubd1W92GiWKg7aac6bOU3G803HbVk82xfP_Ok0JEqAT-FeLWJvpFYSOBbaSkMhCMnra5MgtfhWFrPWqHlhL2urT6atbU-oa0PNE8WXFFJ0-nazXakRroddGk9IwYEUnCd5w7Pddr5UTT8ZuVJY5F0fM7ebRLYyXNDgUnprJWxM-9lb7xAQLHe-M2xDYQCD9pD_2hez_kVn-P_rjLq6n3qjYv2iO5qz9DyvPdyv1ETp5eTTJ_7BGvQq8v1TVtl5jXUcRRcrqFh-dI4VtFlBN6t_ynLNkh5JpUmZEm5rbvfhkLiN6H4BQt2jYGYZklC_uzxWWJxsNCfUmkL2SJEJZuWdYs4cKaERS3IXlUJZNI_lGv7cxj2SMf2CeMx5_wBcbK19"><img src="https://mermaid.ink/img/pako:eNrFlFFPwjAQx7_KpT7Kko2Elya8qCE-aGLAJ5khpe1Yw9Zbug4k4He3OJjbGPig0T5t17tf_nf777aEo5CEkijBNY-ZsfAwDjW4kxfzhWFZDGNECxOOmYTIYAo2lsCyDG4xzVBLbcv8_RHKSG4V6orSIN0Wxrh8b2RYKr_uTyubd1W92GiWKg7aac6bOU3G803HbVk82xfP_Ok0JEqAT-FeLWJvpFYSOBbaSkMhCMnra5MgtfhWFrPWqHlhL2urT6atbU-oa0PNE8WXFFJ0-nazXakRroddGk9IwYEUnCd5w7Pddr5UTT8ZuVJY5F0fM7ebRLYyXNDgUnprJWxM-9lb7xAQLHe-M2xDYQCD9pD_2hez_kVn-P_rjLq6n3qjYv2iO5qz9DyvPdyv1ETp5eTTJ_7BGvQq8v1TVtl5jXUcRRcrqFh-dI4VtFlBN6t_ynLNkh5JpUmZEm5rbvfhkLiN6H4BQt2jYGYZklC_uzxWWJxsNCfUmkL2SJEJZuWdYs4cKaERS3IXlUJZNI_lGv7cxj2SMf2CeMx5_wBcbK19?type=png" alt="" /></a></p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>This is only a brief overview of how the Virtual Dom works. There are several aspects not yet covered in this guide including how the Virtual Dom handles async-components, keyed diffing, and how it uses <a href="https://github.com/fitzgen/bumpalo">bump allocation</a> to efficiently allocate VNodes. If need more information about the Virtual Dom, you can read the code of the <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/core">core</a> crate or reach out to us on <a href="https://discord.gg/XgGxMSkvUM">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overall-goals"><a class="header" href="#overall-goals">Overall Goals</a></h1>
<p>This document outlines some of the overall goals for Dioxus. These goals are not set in stone, but they represent general guidelines for the project.</p>
<p>The goal of Dioxus is to make it easy to build <strong>cross-platform applications that scale</strong>.</p>
<h2 id="cross-platform"><a class="header" href="#cross-platform">Cross-Platform</a></h2>
<p>Dioxus is designed to be cross-platform by default. This means that it should be easy to build applications that run on the web, desktop, and mobile. However, Dioxus should also be flexible enough to allow users to opt into platform-specific features when needed. The <code>use_eval</code> is one example of this. By default, Dioxus does not assume that the platform supports JavaScript, but it does provide a hook that allows users to opt into JavaScript when needed.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>As Dioxus applications grow, they should remain relatively performant without the need for manual optimizations. There will be cases where manual optimizations are needed, but Dioxus should try to make these cases as rare as possible.</p>
<p>One of the benefits of the core architecture of Dioxus is that it delivers reasonable performance even when components are rerendered often. It is based on a Virtual Dom which performs diffing which should prevent unnecessary re-renders even when large parts of the component tree are rerun. On top of this, Dioxus groups static parts of the RSX tree together to skip diffing them entirely.</p>
<h2 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h2>
<p>As teams grow, the Type safety of Rust is a huge advantage. Dioxus should leverage this advantage to make it easy to build applications with large teams.</p>
<p>To take full advantage of Rust's type system, Dioxus should try to avoid exposing public <code>Any</code> types and string-ly typed APIs where possible.</p>
<h2 id="developer-experience"><a class="header" href="#developer-experience">Developer Experience</a></h2>
<p>Dioxus should be easy to learn and ergonomic to use.</p>
<ul>
<li>
<p>The API of Dioxus attempts to remain close to React's API where possible. This makes it easier for people to learn Dioxus if they already know React</p>
</li>
<li>
<p>We can avoid the tradeoff between simplicity and flexibility by providing multiple layers of API: One for the very common use case, one for low-level control</p>
<ul>
<li>Hooks: the hooks crate has the most common use cases, but <code>cx.hook</code> provides a way to access the underlying persistent reference if needed.</li>
<li>The builder pattern in platform Configs: The builder pattern is used to default to the most common use case, but users can change the defaults if needed.</li>
</ul>
</li>
<li>
<p>Documentation:</p>
<ul>
<li>All public APIs should have rust documentation</li>
<li>Examples should be provided for all public features. These examples both serve as documentation and testing. They are checked by CI to ensure that they continue to compile</li>
<li>The most common workflows should be documented in the guide</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap--feature-set"><a class="header" href="#roadmap--feature-set">Roadmap &amp; Feature-set</a></h1>
<p>This feature set and roadmap can help you decide if what Dioxus can do today works for you.</p>
<p>If a feature that you need doesn't exist or you want to contribute to projects on the roadmap, feel free to get involved by <a href="https://discord.gg/XgGxMSkvUM">joining the discord</a>.</p>
<p>Generally, here's the status of each platform:</p>
<ul>
<li>
<p><strong>Web</strong>: Dioxus is a great choice for pure web-apps – especially for CRUD/complex apps. However, it does lack the ecosystem of React, so you might be missing a component library or some useful hook.</p>
</li>
<li>
<p><strong>SSR</strong>: Dioxus is a great choice for pre-rendering, hydration, and rendering HTML on a web endpoint. Be warned – the VirtualDom is not (currently) <code>Send + Sync</code>.</p>
</li>
<li>
<p><strong>Desktop</strong>: You can build very competent single-window desktop apps right now. However, multi-window apps require support from Dioxus core and are not ready.</p>
</li>
<li>
<p><strong>Mobile</strong>: Mobile support is very young. You'll be figuring things out as you go and there are not many support crates for peripherals.</p>
</li>
<li>
<p><strong>LiveView</strong>: LiveView support is very young. You'll be figuring things out as you go. Thankfully, none of it is too hard and any work can be upstreamed into Dioxus.</p>
</li>
</ul>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<hr />
<table><thead><tr><th>Feature</th><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td>Conditional Rendering</td><td>✅</td><td>if/then to hide/show component</td></tr>
<tr><td>Map, Iterator</td><td>✅</td><td>map/filter/reduce to produce rsx!</td></tr>
<tr><td>Keyed Components</td><td>✅</td><td>advanced diffing with keys</td></tr>
<tr><td>Web</td><td>✅</td><td>renderer for web browser</td></tr>
<tr><td>Desktop (webview)</td><td>✅</td><td>renderer for desktop</td></tr>
<tr><td>Shared State (Context)</td><td>✅</td><td>share state through the tree</td></tr>
<tr><td>Hooks</td><td>✅</td><td>memory cells in components</td></tr>
<tr><td>SSR</td><td>✅</td><td>render directly to string</td></tr>
<tr><td>Component Children</td><td>✅</td><td>cx.children() as a list of nodes</td></tr>
<tr><td>Headless components</td><td>✅</td><td>components that don't return real elements</td></tr>
<tr><td>Fragments</td><td>✅</td><td>multiple elements without a real root</td></tr>
<tr><td>Manual Props</td><td>✅</td><td>Manually pass in props with spread syntax</td></tr>
<tr><td>Controlled Inputs</td><td>✅</td><td>stateful wrappers around inputs</td></tr>
<tr><td>CSS/Inline Styles</td><td>✅</td><td>syntax for inline styles/attribute groups</td></tr>
<tr><td>Custom elements</td><td>✅</td><td>Define new element primitives</td></tr>
<tr><td>Suspense</td><td>✅</td><td>schedule future render from future/promise</td></tr>
<tr><td>Integrated error handling</td><td>✅</td><td>Gracefully handle errors with ? syntax</td></tr>
<tr><td>NodeRef</td><td>✅</td><td>gain direct access to nodes</td></tr>
<tr><td>Re-hydration</td><td>✅</td><td>Pre-render to HTML to speed up first contentful paint</td></tr>
<tr><td>Jank-Free Rendering</td><td>✅</td><td>Large diffs are segmented across frames for silky-smooth transitions</td></tr>
<tr><td>Effects</td><td>✅</td><td>Run effects after a component has been committed to render</td></tr>
<tr><td>Portals</td><td>🛠</td><td>Render nodes outside of the traditional tree structure</td></tr>
<tr><td>Cooperative Scheduling</td><td>🛠</td><td>Prioritize important events over non-important events</td></tr>
<tr><td>Server Components</td><td>🛠</td><td>Hybrid components for SPA and Server</td></tr>
<tr><td>Bundle Splitting</td><td>👀</td><td>Efficiently and asynchronously load the app</td></tr>
<tr><td>Lazy Components</td><td>👀</td><td>Dynamically load the new components as the page is loaded</td></tr>
<tr><td>1st class global state</td><td>✅</td><td>redux/recoil/mobx on top of context</td></tr>
<tr><td>Runs natively</td><td>✅</td><td>runs as a portable binary w/o a runtime (Node)</td></tr>
<tr><td>Subtree Memoization</td><td>✅</td><td>skip diffing static element subtrees</td></tr>
<tr><td>High-efficiency templates</td><td>✅</td><td>rsx! calls are translated to templates on the DOM's side</td></tr>
<tr><td>Compile-time correct</td><td>✅</td><td>Throw errors on invalid template layouts</td></tr>
<tr><td>Heuristic Engine</td><td>✅</td><td>track component memory usage to minimize future allocations</td></tr>
<tr><td>Fine-grained reactivity</td><td>👀</td><td>Skip diffing for fine-grain updates</td></tr>
</tbody></table>
<ul>
<li>✅ = implemented and working</li>
<li>🛠 = actively being worked on</li>
<li>👀 = not yet implemented or being worked on</li>
</ul>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p>These Features are planned for the future of Dioxus:</p>
<h3 id="core"><a class="header" href="#core">Core</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Release of Dioxus Core</li>
<li><input disabled="" type="checkbox" checked=""/>
Upgrade documentation to include more theory and be more comprehensive</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for HTML-side templates for lightning-fast dom manipulation</li>
<li><input disabled="" type="checkbox"/>
Support for multiple renderers for same virtualdom (subtrees)</li>
<li><input disabled="" type="checkbox"/>
Support for ThreadSafe (Send + Sync)</li>
<li><input disabled="" type="checkbox"/>
Support for Portals</li>
</ul>
<h3 id="ssr"><a class="header" href="#ssr">SSR</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
SSR Support + Hydration</li>
<li><input disabled="" type="checkbox"/>
Integrated suspense support for SSR</li>
</ul>
<h3 id="desktop"><a class="header" href="#desktop">Desktop</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Declarative window management</li>
<li><input disabled="" type="checkbox"/>
Templates for building/bundling</li>
<li><input disabled="" type="checkbox"/>
Access to Canvas/WebGL context natively</li>
</ul>
<h3 id="mobile"><a class="header" href="#mobile">Mobile</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Mobile standard library
<ul>
<li><input disabled="" type="checkbox"/>
GPS</li>
<li><input disabled="" type="checkbox"/>
Camera</li>
<li><input disabled="" type="checkbox"/>
filesystem</li>
<li><input disabled="" type="checkbox"/>
Biometrics</li>
<li><input disabled="" type="checkbox"/>
WiFi</li>
<li><input disabled="" type="checkbox"/>
Bluetooth</li>
<li><input disabled="" type="checkbox"/>
Notifications</li>
<li><input disabled="" type="checkbox"/>
Clipboard</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Animations</li>
</ul>
<h3 id="bundling-cli"><a class="header" href="#bundling-cli">Bundling (CLI)</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Translation from HTML into RSX</li>
<li><input disabled="" type="checkbox" checked=""/>
Dev server</li>
<li><input disabled="" type="checkbox" checked=""/>
Live reload</li>
<li><input disabled="" type="checkbox" checked=""/>
Translation from JSX into RSX</li>
<li><input disabled="" type="checkbox"/>
Hot module replacement</li>
<li><input disabled="" type="checkbox"/>
Code splitting</li>
<li><input disabled="" type="checkbox"/>
Asset macros</li>
<li><input disabled="" type="checkbox"/>
Css pipeline</li>
<li><input disabled="" type="checkbox"/>
Image pipeline</li>
</ul>
<h3 id="essential-hooks"><a class="header" href="#essential-hooks">Essential hooks</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Router</li>
<li><input disabled="" type="checkbox" checked=""/>
Global state management</li>
<li><input disabled="" type="checkbox"/>
Resize observer</li>
</ul>
<h2 id="work-in-progress"><a class="header" href="#work-in-progress">Work in Progress</a></h2>
<h3 id="build-tool"><a class="header" href="#build-tool">Build Tool</a></h3>
<p>We are currently working on our own build tool called <a href="https://github.com/DioxusLabs/cli">Dioxus CLI</a> which will support:</p>
<ul>
<li>an interactive TUI</li>
<li>on-the-fly reconfiguration</li>
<li>hot CSS reloading</li>
<li>two-way data binding between browser and source code</li>
<li>an interpreter for <code>rsx!</code></li>
<li>ability to publish to github/netlify/vercel</li>
<li>bundling for iOS/Desktop/etc</li>
</ul>
<h3 id="server-component-support"><a class="header" href="#server-component-support">Server Component Support</a></h3>
<p>While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are &quot;live&quot; and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.</p>
<h3 id="native-rendering"><a class="header" href="#native-rendering">Native rendering</a></h3>
<p>We are currently working on a native renderer for Dioxus using WGPU called <a href="https://github.com/DioxusLabs/blitz/">Blitz</a>. This will allow you to build apps that are rendered natively for iOS, Android, and Desktop.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
